/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app-client-internals"],{

/***/ "(app-client)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fsalamane%2FDesktop%2Fft_transcendence%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fapp-router.js&modules=%2FUsers%2Fsalamane%2FDesktop%2Fft_transcendence%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js&modules=%2FUsers%2Fsalamane%2FDesktop%2Fft_transcendence%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js&modules=%2FUsers%2Fsalamane%2FDesktop%2Fft_transcendence%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Ferror-boundary.js&modules=%2FUsers%2Fsalamane%2FDesktop%2Fft_transcendence%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fstatic-generation-searchparams-bailout-provider.js&server=false!":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fsalamane%2FDesktop%2Fft_transcendence%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fapp-router.js&modules=%2FUsers%2Fsalamane%2FDesktop%2Fft_transcendence%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js&modules=%2FUsers%2Fsalamane%2FDesktop%2Fft_transcendence%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js&modules=%2FUsers%2Fsalamane%2FDesktop%2Fft_transcendence%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Ferror-boundary.js&modules=%2FUsers%2Fsalamane%2FDesktop%2Fft_transcendence%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fstatic-generation-searchparams-bailout-provider.js&server=false! ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/app-router.js */ \"(app-client)/./node_modules/next/dist/client/components/app-router.js\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/layout-router.js */ \"(app-client)/./node_modules/next/dist/client/components/layout-router.js\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/render-from-template-context.js */ \"(app-client)/./node_modules/next/dist/client/components/render-from-template-context.js\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/error-boundary.js */ \"(app-client)/./node_modules/next/dist/client/components/error-boundary.js\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/static-generation-searchparams-bailout-provider.js */ \"(app-client)/./node_modules/next/dist/client/components/static-generation-searchparams-bailout-provider.js\", 23))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1mbGlnaHQtY2xpZW50LWVudHJ5LWxvYWRlci5qcz9tb2R1bGVzPSUyRlVzZXJzJTJGc2FsYW1hbmUlMkZEZXNrdG9wJTJGZnRfdHJhbnNjZW5kZW5jZSUyRm5vZGVfbW9kdWxlcyUyRm5leHQlMkZkaXN0JTJGY2xpZW50JTJGY29tcG9uZW50cyUyRmFwcC1yb3V0ZXIuanMmbW9kdWxlcz0lMkZVc2VycyUyRnNhbGFtYW5lJTJGRGVza3RvcCUyRmZ0X3RyYW5zY2VuZGVuY2UlMkZub2RlX21vZHVsZXMlMkZuZXh0JTJGZGlzdCUyRmNsaWVudCUyRmNvbXBvbmVudHMlMkZsYXlvdXQtcm91dGVyLmpzJm1vZHVsZXM9JTJGVXNlcnMlMkZzYWxhbWFuZSUyRkRlc2t0b3AlMkZmdF90cmFuc2NlbmRlbmNlJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZjbGllbnQlMkZjb21wb25lbnRzJTJGcmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qcyZtb2R1bGVzPSUyRlVzZXJzJTJGc2FsYW1hbmUlMkZEZXNrdG9wJTJGZnRfdHJhbnNjZW5kZW5jZSUyRm5vZGVfbW9kdWxlcyUyRm5leHQlMkZkaXN0JTJGY2xpZW50JTJGY29tcG9uZW50cyUyRmVycm9yLWJvdW5kYXJ5LmpzJm1vZHVsZXM9JTJGVXNlcnMlMkZzYWxhbWFuZSUyRkRlc2t0b3AlMkZmdF90cmFuc2NlbmRlbmNlJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZjbGllbnQlMkZjb21wb25lbnRzJTJGc3RhdGljLWdlbmVyYXRpb24tc2VhcmNocGFyYW1zLWJhaWxvdXQtcHJvdmlkZXIuanMmc2VydmVyPWZhbHNlIS5qcyIsIm1hcHBpbmdzIjoiQUFBQSx5T0FBb0k7QUFDcEksK09BQXVJO0FBQ3ZJLDZRQUFzSjtBQUN0SixpUEFBd0k7QUFDeEkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz9mMzJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL3NhbGFtYW5lL0Rlc2t0b3AvZnRfdHJhbnNjZW5kZW5jZS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2FwcC1yb3V0ZXIuanNcIik7XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9zYWxhbWFuZS9EZXNrdG9wL2Z0X3RyYW5zY2VuZGVuY2Uvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9sYXlvdXQtcm91dGVyLmpzXCIpO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvc2FsYW1hbmUvRGVza3RvcC9mdF90cmFuc2NlbmRlbmNlL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qc1wiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL3NhbGFtYW5lL0Rlc2t0b3AvZnRfdHJhbnNjZW5kZW5jZS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2Vycm9yLWJvdW5kYXJ5LmpzXCIpO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvc2FsYW1hbmUvRGVza3RvcC9mdF90cmFuc2NlbmRlbmNlL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvc3RhdGljLWdlbmVyYXRpb24tc2VhcmNocGFyYW1zLWJhaWxvdXQtcHJvdmlkZXIuanNcIikiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fsalamane%2FDesktop%2Fft_transcendence%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fapp-router.js&modules=%2FUsers%2Fsalamane%2FDesktop%2Fft_transcendence%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js&modules=%2FUsers%2Fsalamane%2FDesktop%2Fft_transcendence%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js&modules=%2FUsers%2Fsalamane%2FDesktop%2Fft_transcendence%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Ferror-boundary.js&modules=%2FUsers%2Fsalamane%2FDesktop%2Fft_transcendence%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fstatic-generation-searchparams-bailout-provider.js&server=false!\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/hooks-server-context.js":
/*!**************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/hooks-server-context.js ***!
  \**************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DYNAMIC_ERROR_CODE: function() {\n        return DYNAMIC_ERROR_CODE;\n    },\n    DynamicServerError: function() {\n        return DynamicServerError;\n    }\n});\nconst DYNAMIC_ERROR_CODE = \"DYNAMIC_SERVER_USAGE\";\nclass DynamicServerError extends Error {\n    constructor(type){\n        super(\"Dynamic server usage: \" + type);\n        this.digest = DYNAMIC_ERROR_CODE;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=hooks-server-context.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9ob29rcy1zZXJ2ZXItY29udGV4dC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGLEtBQU1DLENBQUFBLENBR047QUFDQSxTQUFTRyxRQUFRQyxNQUFNLEVBQUVDLEdBQUcsRUFBRTtJQUMxQixJQUFJLElBQUlDLFFBQVFELElBQUlULE9BQU9DLGNBQWMsQ0FBQ08sUUFBUUUsTUFBTTtRQUNwREMsWUFBWSxJQUFJO1FBQ2hCQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRTCxTQUFTO0lBQ2JHLG9CQUFvQixXQUFXO1FBQzNCLE9BQU9BO0lBQ1g7SUFDQUMsb0JBQW9CLFdBQVc7UUFDM0IsT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTUQscUJBQXFCO0FBQzNCLE1BQU1DLDJCQUEyQk87SUFDN0JDLFlBQVlDLElBQUksQ0FBQztRQUNiLEtBQUssQ0FBQywyQkFBMkJBO1FBQ2pDLElBQUksQ0FBQ0MsTUFBTSxHQUFHWDtJQUNsQjtBQUNKO0FBRUEsSUFBSSxDQUFDLE9BQU9ILFFBQVFlLE9BQU8sS0FBSyxjQUFlLE9BQU9mLFFBQVFlLE9BQU8sS0FBSyxZQUFZZixRQUFRZSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9mLFFBQVFlLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktsQixPQUFPQyxjQUFjLENBQUNDLFFBQVFlLE9BQU8sRUFBRSxjQUFjO1FBQUVkLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPbUIsTUFBTSxDQUFDakIsUUFBUWUsT0FBTyxFQUFFZjtJQUMvQkUsT0FBT0YsT0FBTyxHQUFHQSxRQUFRZSxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxnREFBZ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9ob29rcy1zZXJ2ZXItY29udGV4dC5qcz8wMDlhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgRFlOQU1JQ19FUlJPUl9DT0RFOiBudWxsLFxuICAgIER5bmFtaWNTZXJ2ZXJFcnJvcjogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBEWU5BTUlDX0VSUk9SX0NPREU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gRFlOQU1JQ19FUlJPUl9DT0RFO1xuICAgIH0sXG4gICAgRHluYW1pY1NlcnZlckVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIER5bmFtaWNTZXJ2ZXJFcnJvcjtcbiAgICB9XG59KTtcbmNvbnN0IERZTkFNSUNfRVJST1JfQ09ERSA9IFwiRFlOQU1JQ19TRVJWRVJfVVNBR0VcIjtcbmNsYXNzIER5bmFtaWNTZXJ2ZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlKXtcbiAgICAgICAgc3VwZXIoXCJEeW5hbWljIHNlcnZlciB1c2FnZTogXCIgKyB0eXBlKTtcbiAgICAgICAgdGhpcy5kaWdlc3QgPSBEWU5BTUlDX0VSUk9SX0NPREU7XG4gICAgfVxufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob29rcy1zZXJ2ZXItY29udGV4dC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJEWU5BTUlDX0VSUk9SX0NPREUiLCJEeW5hbWljU2VydmVyRXJyb3IiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwidHlwZSIsImRpZ2VzdCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/hooks-server-context.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/layout-router.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/components/layout-router.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return OuterLayoutRouter;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-client)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-client)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom */ \"(app-client)/./node_modules/next/dist/compiled/react-dom/index.js\"));\nconst _approutercontext = __webpack_require__(/*! ../../shared/lib/app-router-context */ \"(app-client)/./node_modules/next/dist/shared/lib/app-router-context.js\");\nconst _fetchserverresponse = __webpack_require__(/*! ./router-reducer/fetch-server-response */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _infinitepromise = __webpack_require__(/*! ./infinite-promise */ \"(app-client)/./node_modules/next/dist/client/components/infinite-promise.js\");\nconst _errorboundary = __webpack_require__(/*! ./error-boundary */ \"(app-client)/./node_modules/next/dist/client/components/error-boundary.js\");\nconst _matchsegments = __webpack_require__(/*! ./match-segments */ \"(app-client)/./node_modules/next/dist/client/components/match-segments.js\");\nconst _handlesmoothscroll = __webpack_require__(/*! ../../shared/lib/router/utils/handle-smooth-scroll */ \"(app-client)/./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\");\nconst _redirectboundary = __webpack_require__(/*! ./redirect-boundary */ \"(app-client)/./node_modules/next/dist/client/components/redirect-boundary.js\");\nconst _notfoundboundary = __webpack_require__(/*! ./not-found-boundary */ \"(app-client)/./node_modules/next/dist/client/components/not-found-boundary.js\");\nconst _getsegmentvalue = __webpack_require__(/*! ./router-reducer/reducers/get-segment-value */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js\");\nconst _createroutercachekey = __webpack_require__(/*! ./router-reducer/create-router-cache-key */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js\");\n/**\n * Add refetch marker to router state at the point of the current layout segment.\n * This ensures the response returned is not further down than the current layout segment.\n */ function walkAddRefetch(segmentPathToWalk, treeToRecreate) {\n    if (segmentPathToWalk) {\n        const [segment, parallelRouteKey] = segmentPathToWalk;\n        const isLast = segmentPathToWalk.length === 2;\n        if ((0, _matchsegments.matchSegment)(treeToRecreate[0], segment)) {\n            if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {\n                if (isLast) {\n                    const subTree = walkAddRefetch(undefined, treeToRecreate[1][parallelRouteKey]);\n                    return [\n                        treeToRecreate[0],\n                        {\n                            ...treeToRecreate[1],\n                            [parallelRouteKey]: [\n                                subTree[0],\n                                subTree[1],\n                                subTree[2],\n                                \"refetch\"\n                            ]\n                        }\n                    ];\n                }\n                return [\n                    treeToRecreate[0],\n                    {\n                        ...treeToRecreate[1],\n                        [parallelRouteKey]: walkAddRefetch(segmentPathToWalk.slice(2), treeToRecreate[1][parallelRouteKey])\n                    }\n                ];\n            }\n        }\n    }\n    return treeToRecreate;\n}\n// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available\n/**\n * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning\n */ function findDOMNode(instance) {\n    // Tree-shake for server bundle\n    if (false) {}\n    // Only apply strict mode warning when not in production\n    if (true) {\n        const originalConsoleError = console.error;\n        try {\n            console.error = function() {\n                for(var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++){\n                    messages[_key] = arguments[_key];\n                }\n                // Ignore strict mode warning for the findDomNode call below\n                if (!messages[0].includes(\"Warning: %s is deprecated in StrictMode.\")) {\n                    originalConsoleError(...messages);\n                }\n            };\n            return _reactdom.default.findDOMNode(instance);\n        } finally{\n            console.error = originalConsoleError;\n        }\n    }\n    return _reactdom.default.findDOMNode(instance);\n}\nconst rectProperties = [\n    \"bottom\",\n    \"height\",\n    \"left\",\n    \"right\",\n    \"top\",\n    \"width\",\n    \"x\",\n    \"y\"\n];\n/**\n * Check if a HTMLElement is hidden.\n */ function elementCanScroll(element) {\n    // Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`\n    // because `offsetParent` doesn't consider document/body\n    const rect = element.getBoundingClientRect();\n    return rectProperties.every((item)=>rect[item] === 0);\n}\n/**\n * Check if the top corner of the HTMLElement is in the viewport.\n */ function topOfElementInViewport(element, viewportHeight) {\n    const rect = element.getBoundingClientRect();\n    return rect.top >= 0 && rect.top <= viewportHeight;\n}\n/**\n * Find the DOM node for a hash fragment.\n * If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.\n * If the hash fragment is an id, the page has to scroll to the element with that id.\n * If the hash fragment is a name, the page has to scroll to the first element with that name.\n */ function getHashFragmentDomNode(hashFragment) {\n    // If the hash fragment is `top` the page has to scroll to the top of the page.\n    if (hashFragment === \"top\") {\n        return document.body;\n    }\n    var _document_getElementById;\n    // If the hash fragment is an id, the page has to scroll to the element with that id.\n    return (_document_getElementById = document.getElementById(hashFragment)) != null ? _document_getElementById : document.getElementsByName(hashFragment)[0];\n}\nclass InnerScrollAndFocusHandler extends _react.default.Component {\n    componentDidMount() {\n        this.handlePotentialScroll();\n    }\n    componentDidUpdate() {\n        // Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.\n        if (this.props.focusAndScrollRef.apply) {\n            this.handlePotentialScroll();\n        }\n    }\n    render() {\n        return this.props.children;\n    }\n    constructor(...args){\n        super(...args);\n        this.handlePotentialScroll = ()=>{\n            // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.\n            const { focusAndScrollRef , segmentPath  } = this.props;\n            if (focusAndScrollRef.apply) {\n                // segmentPaths is an array of segment paths that should be scrolled to\n                // if the current segment path is not in the array, the scroll is not applied\n                // unless the array is empty, in which case the scroll is always applied\n                if (focusAndScrollRef.segmentPaths.length !== 0 && !focusAndScrollRef.segmentPaths.some((scrollRefSegmentPath)=>segmentPath.every((segment, index)=>(0, _matchsegments.matchSegment)(segment, scrollRefSegmentPath[index])))) {\n                    return;\n                }\n                let domNode = null;\n                const hashFragment = focusAndScrollRef.hashFragment;\n                if (hashFragment) {\n                    domNode = getHashFragmentDomNode(hashFragment);\n                }\n                // `findDOMNode` is tricky because it returns just the first child if the component is a fragment.\n                // This already caused a bug where the first child was a <link/> in head.\n                if (!domNode) {\n                    domNode = findDOMNode(this);\n                }\n                // TODO-APP: Handle the case where we couldn't select any DOM node, even higher up in the layout-router above the current segmentPath.\n                // If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.\n                if (!(domNode instanceof Element)) {\n                    return;\n                }\n                // Verify if the element is a HTMLElement and if it's visible on screen (e.g. not display: none).\n                // If the element is not a HTMLElement or not visible we try to select the next sibling and try again.\n                while(!(domNode instanceof HTMLElement) || elementCanScroll(domNode)){\n                    // TODO-APP: Handle the case where we couldn't select any DOM node, even higher up in the layout-router above the current segmentPath.\n                    // No siblings found that are visible so we handle scroll higher up in the tree instead.\n                    if (domNode.nextElementSibling === null) {\n                        return;\n                    }\n                    domNode = domNode.nextElementSibling;\n                }\n                // State is mutated to ensure that the focus and scroll is applied only once.\n                focusAndScrollRef.apply = false;\n                focusAndScrollRef.hashFragment = null;\n                focusAndScrollRef.segmentPaths = [];\n                (0, _handlesmoothscroll.handleSmoothScroll)(()=>{\n                    // In case of hash scroll we need to scroll to the top of the element\n                    if (hashFragment) {\n                        window.scrollTo(0, domNode.offsetTop);\n                        return;\n                    }\n                    // Store the current viewport height because reading `clientHeight` causes a reflow,\n                    // and it won't change during this function.\n                    const htmlElement = document.documentElement;\n                    const viewportHeight = htmlElement.clientHeight;\n                    // If the element's top edge is already in the viewport, exit early.\n                    if (topOfElementInViewport(domNode, viewportHeight)) {\n                        return;\n                    }\n                    // Otherwise, try scrolling go the top of the document to be backward compatible with pages\n                    // scrollIntoView() called on `<html/>` element scrolls horizontally on chrome and firefox (that shouldn't happen)\n                    // We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left\n                    // scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically\n                    htmlElement.scrollTop = 0;\n                    // Scroll to domNode if domNode is not in viewport when scrolled to top of document\n                    if (!topOfElementInViewport(domNode, viewportHeight)) {\n                        domNode.scrollIntoView();\n                    }\n                }, {\n                    // We will force layout by querying domNode position\n                    dontForceLayout: true\n                });\n                // Set focus on the element\n                domNode.focus();\n            }\n        };\n    }\n}\nfunction ScrollAndFocusHandler(param) {\n    let { segmentPath , children  } = param;\n    const context = (0, _react.useContext)(_approutercontext.GlobalLayoutRouterContext);\n    if (!context) {\n        throw new Error(\"invariant global layout router not mounted\");\n    }\n    return /*#__PURE__*/ _react.default.createElement(InnerScrollAndFocusHandler, {\n        segmentPath: segmentPath,\n        focusAndScrollRef: context.focusAndScrollRef\n    }, children);\n}\n_c = ScrollAndFocusHandler;\n/**\n * InnerLayoutRouter handles rendering the provided segment based on the cache.\n */ function InnerLayoutRouter(param) {\n    let { parallelRouterKey , url , childNodes , childProp , segmentPath , tree , // isActive,\n    cacheKey  } = param;\n    const context = (0, _react.useContext)(_approutercontext.GlobalLayoutRouterContext);\n    if (!context) {\n        throw new Error(\"invariant global layout router not mounted\");\n    }\n    const { changeByServerResponse , tree: fullTree  } = context;\n    // Read segment path from the parallel router cache node.\n    let childNode = childNodes.get(cacheKey);\n    // If childProp is available this means it's the Flight / SSR case.\n    if (childProp && // TODO-APP: verify if this can be null based on user code\n    childProp.current !== null) {\n        if (!childNode) {\n            // Add the segment's subTreeData to the cache.\n            // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n            childNodes.set(cacheKey, {\n                status: _approutercontext.CacheStates.READY,\n                data: null,\n                subTreeData: childProp.current,\n                parallelRoutes: new Map()\n            });\n            // In the above case childNode was set on childNodes, so we have to get it from the cacheNodes again.\n            childNode = childNodes.get(cacheKey);\n        } else {\n            if (childNode.status === _approutercontext.CacheStates.LAZY_INITIALIZED) {\n                // @ts-expect-error we're changing it's type!\n                childNode.status = _approutercontext.CacheStates.READY;\n                // @ts-expect-error\n                childNode.subTreeData = childProp.current;\n            }\n        }\n    }\n    // When childNode is not available during rendering client-side we need to fetch it from the server.\n    if (!childNode || childNode.status === _approutercontext.CacheStates.LAZY_INITIALIZED) {\n        /**\n     * Router state with refetch marker added\n     */ // TODO-APP: remove ''\n        const refetchTree = walkAddRefetch([\n            \"\",\n            ...segmentPath\n        ], fullTree);\n        /**\n     * Flight data fetch kicked off during render and put into the cache.\n     */ childNodes.set(cacheKey, {\n            status: _approutercontext.CacheStates.DATA_FETCH,\n            data: (0, _fetchserverresponse.fetchServerResponse)(new URL(url, location.origin), refetchTree, context.nextUrl),\n            subTreeData: null,\n            head: childNode && childNode.status === _approutercontext.CacheStates.LAZY_INITIALIZED ? childNode.head : undefined,\n            parallelRoutes: childNode && childNode.status === _approutercontext.CacheStates.LAZY_INITIALIZED ? childNode.parallelRoutes : new Map()\n        });\n        // In the above case childNode was set on childNodes, so we have to get it from the cacheNodes again.\n        childNode = childNodes.get(cacheKey);\n    }\n    // This case should never happen so it throws an error. It indicates there's a bug in the Next.js.\n    if (!childNode) {\n        throw new Error(\"Child node should always exist\");\n    }\n    // This case should never happen so it throws an error. It indicates there's a bug in the Next.js.\n    if (childNode.subTreeData && childNode.data) {\n        throw new Error(\"Child node should not have both subTreeData and data\");\n    }\n    // If cache node has a data request we have to unwrap response by `use` and update the cache.\n    if (childNode.data) {\n        /**\n     * Flight response data\n     */ // When the data has not resolved yet `use` will suspend here.\n        const [flightData, overrideCanonicalUrl] = (0, _react.use)(childNode.data);\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === \"string\") {\n            window.location.href = url;\n            return null;\n        }\n        // segmentPath from the server does not match the layout's segmentPath\n        childNode.data = null;\n        // setTimeout is used to start a new transition during render, this is an intentional hack around React.\n        setTimeout(()=>{\n            // @ts-ignore startTransition exists\n            _react.default.startTransition(()=>{\n                changeByServerResponse(fullTree, flightData, overrideCanonicalUrl);\n            });\n        });\n        // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.\n        (0, _react.use)((0, _infinitepromise.createInfinitePromise)());\n    }\n    // If cache node has no subTreeData and no data request we have to infinitely suspend as the data will likely flow in from another place.\n    // TODO-APP: double check users can't return null in a component that will kick in here.\n    if (!childNode.subTreeData) {\n        (0, _react.use)((0, _infinitepromise.createInfinitePromise)());\n    }\n    const subtree = /*#__PURE__*/ _react.default.createElement(_approutercontext.LayoutRouterContext.Provider, {\n        value: {\n            tree: tree[1][parallelRouterKey],\n            childNodes: childNode.parallelRoutes,\n            // TODO-APP: overriding of url for parallel routes\n            url: url\n        }\n    }, childNode.subTreeData);\n    // Ensure root layout is not wrapped in a div as the root layout renders `<html>`\n    return subtree;\n}\n_c1 = InnerLayoutRouter;\n/**\n * Renders suspense boundary with the provided \"loading\" property as the fallback.\n * If no loading property is provided it renders the children without a suspense boundary.\n */ function LoadingBoundary(param) {\n    let { children , loading , loadingStyles , hasLoading  } = param;\n    if (hasLoading) {\n        return /*#__PURE__*/ _react.default.createElement(_react.default.Suspense, {\n            fallback: /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, loadingStyles, loading)\n        }, children);\n    }\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, children);\n}\n_c2 = LoadingBoundary;\nfunction OuterLayoutRouter(param) {\n    let { parallelRouterKey , segmentPath , childProp , error , errorStyles , templateStyles , loading , loadingStyles , hasLoading , template , notFound , notFoundStyles , asNotFound , styles  } = param;\n    const context = (0, _react.useContext)(_approutercontext.LayoutRouterContext);\n    if (!context) {\n        throw new Error(\"invariant expected layout router to be mounted\");\n    }\n    const { childNodes , tree , url  } = context;\n    // Get the current parallelRouter cache node\n    let childNodesForParallelRouter = childNodes.get(parallelRouterKey);\n    // If the parallel router cache node does not exist yet, create it.\n    // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n    if (!childNodesForParallelRouter) {\n        childNodes.set(parallelRouterKey, new Map());\n        childNodesForParallelRouter = childNodes.get(parallelRouterKey);\n    }\n    // Get the active segment in the tree\n    // The reason arrays are used in the data format is that these are transferred from the server to the browser so it's optimized to save bytes.\n    const treeSegment = tree[1][parallelRouterKey][0];\n    const childPropSegment = childProp.segment;\n    // If segment is an array it's a dynamic route and we want to read the dynamic route value as the segment to get from the cache.\n    const currentChildSegmentValue = (0, _getsegmentvalue.getSegmentValue)(treeSegment);\n    /**\n   * Decides which segments to keep rendering, all segments that are not active will be wrapped in `<Offscreen>`.\n   */ // TODO-APP: Add handling of `<Offscreen>` when it's available.\n    const preservedSegments = [\n        treeSegment\n    ];\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, styles, preservedSegments.map((preservedSegment)=>{\n        const isChildPropSegment = (0, _matchsegments.matchSegment)(preservedSegment, childPropSegment);\n        const preservedSegmentValue = (0, _getsegmentvalue.getSegmentValue)(preservedSegment);\n        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(preservedSegment);\n        return(/*\n            - Error boundary\n              - Only renders error boundary if error component is provided.\n              - Rendered for each segment to ensure they have their own error state.\n            - Loading boundary\n              - Only renders suspense boundary if loading components is provided.\n              - Rendered for each segment to ensure they have their own loading state.\n              - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.\n          */ /*#__PURE__*/ _react.default.createElement(_approutercontext.TemplateContext.Provider, {\n            key: (0, _createroutercachekey.createRouterCacheKey)(preservedSegment, true),\n            value: /*#__PURE__*/ _react.default.createElement(ScrollAndFocusHandler, {\n                segmentPath: segmentPath\n            }, /*#__PURE__*/ _react.default.createElement(_errorboundary.ErrorBoundary, {\n                errorComponent: error,\n                errorStyles: errorStyles\n            }, /*#__PURE__*/ _react.default.createElement(LoadingBoundary, {\n                hasLoading: hasLoading,\n                loading: loading,\n                loadingStyles: loadingStyles\n            }, /*#__PURE__*/ _react.default.createElement(_notfoundboundary.NotFoundBoundary, {\n                notFound: notFound,\n                notFoundStyles: notFoundStyles,\n                asNotFound: asNotFound\n            }, /*#__PURE__*/ _react.default.createElement(_redirectboundary.RedirectBoundary, null, /*#__PURE__*/ _react.default.createElement(InnerLayoutRouter, {\n                parallelRouterKey: parallelRouterKey,\n                url: url,\n                tree: tree,\n                childNodes: childNodesForParallelRouter,\n                childProp: isChildPropSegment ? childProp : null,\n                segmentPath: segmentPath,\n                cacheKey: cacheKey,\n                isActive: currentChildSegmentValue === preservedSegmentValue\n            }))))))\n        }, /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, templateStyles, template)));\n    }));\n}\n_c3 = OuterLayoutRouter;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=layout-router.js.map\nvar _c, _c1, _c2, _c3;\n$RefreshReg$(_c, \"ScrollAndFocusHandler\");\n$RefreshReg$(_c1, \"InnerLayoutRouter\");\n$RefreshReg$(_c2, \"LoadingBoundary\");\n$RefreshReg$(_c3, \"OuterLayoutRouter\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9sYXlvdXQtcm91dGVyLmpzLmpzIiwibWFwcGluZ3MiOiJxREFDYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGSCwyQ0FHZTtJQUNYSSxZQUFZLElBQUk7SUFDaEJDLEtBQUssV0FBVztRQUNaLE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQywyQkFBMkJDLG1CQUFPQSxDQUFDLHlIQUF5QztBQUNsRixNQUFNQyw0QkFBNEJELG1CQUFPQSxDQUFDLDJIQUEwQztBQUNwRixNQUFNRSxTQUFTLFdBQVcsR0FBR0QsMEJBQTBCRSxDQUFDLENBQUNILG1CQUFPQSxDQUFDLDRFQUFPO0FBQ3hFLE1BQU1JLFlBQVksV0FBVyxHQUFHTCx5QkFBeUJJLENBQUMsQ0FBQ0gsbUJBQU9BLENBQUMsb0ZBQVc7QUFDOUUsTUFBTUssb0JBQW9CTCxtQkFBT0EsQ0FBQyxtSEFBcUM7QUFDdkUsTUFBTU0sdUJBQXVCTixtQkFBT0EsQ0FBQywrSUFBd0M7QUFDN0UsTUFBTU8sbUJBQW1CUCxtQkFBT0EsQ0FBQyx1R0FBb0I7QUFDckQsTUFBTVEsaUJBQWlCUixtQkFBT0EsQ0FBQyxtR0FBa0I7QUFDakQsTUFBTVMsaUJBQWlCVCxtQkFBT0EsQ0FBQyxtR0FBa0I7QUFDakQsTUFBTVUsc0JBQXNCVixtQkFBT0EsQ0FBQyxpSkFBb0Q7QUFDeEYsTUFBTVcsb0JBQW9CWCxtQkFBT0EsQ0FBQyx5R0FBcUI7QUFDdkQsTUFBTVksb0JBQW9CWixtQkFBT0EsQ0FBQywyR0FBc0I7QUFDeEQsTUFBTWEsbUJBQW1CYixtQkFBT0EsQ0FBQyx5SkFBNkM7QUFDOUUsTUFBTWMsd0JBQXdCZCxtQkFBT0EsQ0FBQyxtSkFBMEM7QUFFaEY7OztDQUdDLEdBQUcsU0FBU2UsZUFBZUMsaUJBQWlCLEVBQUVDLGNBQWMsRUFBRTtJQUMzRCxJQUFJRCxt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VWQsNkJBQTZCTTtZQUMzQztRQUNKLEdBQUcsV0FBVyxHQUFHN0osT0FBT3VDLE9BQU8sQ0FBQ3dELGFBQWEsQ0FBQy9GLE9BQU91QyxPQUFPLENBQUNxRyxRQUFRLEVBQUUsSUFBSSxFQUFFRSxnQkFBZ0JDO0lBQ2pHO0FBQ0o7TUFsRVNuSjtBQW9FVCxJQUFJLENBQUMsT0FBT0osUUFBUStDLE9BQU8sS0FBSyxjQUFlLE9BQU8vQyxRQUFRK0MsT0FBTyxLQUFLLFlBQVkvQyxRQUFRK0MsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPL0MsUUFBUStDLE9BQU8sQ0FBQytILFVBQVUsS0FBSyxhQUFhO0lBQ3JLaEwsT0FBT0MsY0FBYyxDQUFDQyxRQUFRK0MsT0FBTyxFQUFFLGNBQWM7UUFBRTlDLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPaUwsTUFBTSxDQUFDL0ssUUFBUStDLE9BQU8sRUFBRS9DO0lBQy9CZ0wsT0FBT2hMLE9BQU8sR0FBR0EsUUFBUStDLE9BQU87QUFDbEMsQ0FBQyxDQUVELHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2xheW91dC1yb3V0ZXIuanM/MGJmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIC8qKlxuICogT3V0ZXJMYXlvdXRSb3V0ZXIgaGFuZGxlcyB0aGUgY3VycmVudCBzZWdtZW50IGFzIHdlbGwgYXMgPE9mZnNjcmVlbj4gcmVuZGVyaW5nIG9mIG90aGVyIHNlZ21lbnRzLlxuICogSXQgY2FuIGJlIHJlbmRlcmVkIG5leHQgdG8gZWFjaCBvdGhlciB3aXRoIGEgZGlmZmVyZW50IGBwYXJhbGxlbFJvdXRlcktleWAsIGFsbG93aW5nIGZvciBQYXJhbGxlbCByb3V0ZXMuXG4gKi8gXCJkZWZhdWx0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBPdXRlckxheW91dFJvdXRlcjtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHRcIik7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmRcIik7XG5jb25zdCBfcmVhY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuXyhyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgX3JlYWN0ZG9tID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwicmVhY3QtZG9tXCIpKTtcbmNvbnN0IF9hcHByb3V0ZXJjb250ZXh0ID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0XCIpO1xuY29uc3QgX2ZldGNoc2VydmVycmVzcG9uc2UgPSByZXF1aXJlKFwiLi9yb3V0ZXItcmVkdWNlci9mZXRjaC1zZXJ2ZXItcmVzcG9uc2VcIik7XG5jb25zdCBfaW5maW5pdGVwcm9taXNlID0gcmVxdWlyZShcIi4vaW5maW5pdGUtcHJvbWlzZVwiKTtcbmNvbnN0IF9lcnJvcmJvdW5kYXJ5ID0gcmVxdWlyZShcIi4vZXJyb3ItYm91bmRhcnlcIik7XG5jb25zdCBfbWF0Y2hzZWdtZW50cyA9IHJlcXVpcmUoXCIuL21hdGNoLXNlZ21lbnRzXCIpO1xuY29uc3QgX2hhbmRsZXNtb290aHNjcm9sbCA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9oYW5kbGUtc21vb3RoLXNjcm9sbFwiKTtcbmNvbnN0IF9yZWRpcmVjdGJvdW5kYXJ5ID0gcmVxdWlyZShcIi4vcmVkaXJlY3QtYm91bmRhcnlcIik7XG5jb25zdCBfbm90Zm91bmRib3VuZGFyeSA9IHJlcXVpcmUoXCIuL25vdC1mb3VuZC1ib3VuZGFyeVwiKTtcbmNvbnN0IF9nZXRzZWdtZW50dmFsdWUgPSByZXF1aXJlKFwiLi9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9nZXQtc2VnbWVudC12YWx1ZVwiKTtcbmNvbnN0IF9jcmVhdGVyb3V0ZXJjYWNoZWtleSA9IHJlcXVpcmUoXCIuL3JvdXRlci1yZWR1Y2VyL2NyZWF0ZS1yb3V0ZXItY2FjaGUta2V5XCIpO1xuXG4vKipcbiAqIEFkZCByZWZldGNoIG1hcmtlciB0byByb3V0ZXIgc3RhdGUgYXQgdGhlIHBvaW50IG9mIHRoZSBjdXJyZW50IGxheW91dCBzZWdtZW50LlxuICogVGhpcyBlbnN1cmVzIHRoZSByZXNwb25zZSByZXR1cm5lZCBpcyBub3QgZnVydGhlciBkb3duIHRoYW4gdGhlIGN1cnJlbnQgbGF5b3V0IHNlZ21lbnQuXG4gKi8gZnVuY3Rpb24gd2Fsa0FkZFJlZmV0Y2goc2VnbWVudFBhdGhUb1dhbGssIHRyZWVUb1JlY3JlYXRlKSB7XG4gICAgaWYgKHNlZ21lbnRQYXRoVG9XYWxrKSB7XG4gICAgICAgIGNvbnN0IFtzZWdtZW50LCBwYXJhbGxlbFJvdXRlS2V5XSA9IHNlZ21lbnRQYXRoVG9XYWxrO1xuICAgICAgICBjb25zdCBpc0xhc3QgPSBzZWdtZW50UGF0aFRvV2Fsay5sZW5ndGggPT09IDI7XG4gICAgICAgIGlmICgoMCwgX21hdGNoc2VnbWVudHMubWF0Y2hTZWdtZW50KSh0cmVlVG9SZWNyZWF0ZVswXSwgc2VnbWVudCkpIHtcbiAgICAgICAgICAgIGlmICh0cmVlVG9SZWNyZWF0ZVsxXS5oYXNPd25Qcm9wZXJ0eShwYXJhbGxlbFJvdXRlS2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0xhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ViVHJlZSA9IHdhbGtBZGRSZWZldGNoKHVuZGVmaW5lZCwgdHJlZVRvUmVjcmVhdGVbMV1bcGFyYWxsZWxSb3V0ZUtleV0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZVRvUmVjcmVhdGVbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udHJlZVRvUmVjcmVhdGVbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3BhcmFsbGVsUm91dGVLZXldOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YlRyZWVbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YlRyZWVbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YlRyZWVbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicmVmZXRjaFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB0cmVlVG9SZWNyZWF0ZVswXSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4udHJlZVRvUmVjcmVhdGVbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbcGFyYWxsZWxSb3V0ZUtleV06IHdhbGtBZGRSZWZldGNoKHNlZ21lbnRQYXRoVG9XYWxrLnNsaWNlKDIpLCB0cmVlVG9SZWNyZWF0ZVsxXVtwYXJhbGxlbFJvdXRlS2V5XSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRyZWVUb1JlY3JlYXRlO1xufVxuLy8gVE9ETy1BUFA6IFJlcGxhY2Ugd2l0aCBuZXcgUmVhY3QgQVBJIGZvciBmaW5kaW5nIGRvbSBub2RlcyB3aXRob3V0IGEgYHJlZmAgd2hlbiBhdmFpbGFibGVcbi8qKlxuICogV3JhcHMgUmVhY3RET00uZmluZERPTU5vZGUgd2l0aCBhZGRpdGlvbmFsIGxvZ2ljIHRvIGhpZGUgUmVhY3QgU3RyaWN0IE1vZGUgd2FybmluZ1xuICovIGZ1bmN0aW9uIGZpbmRET01Ob2RlKGluc3RhbmNlKSB7XG4gICAgLy8gVHJlZS1zaGFrZSBmb3Igc2VydmVyIGJ1bmRsZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gbnVsbDtcbiAgICAvLyBPbmx5IGFwcGx5IHN0cmljdCBtb2RlIHdhcm5pbmcgd2hlbiBub3QgaW4gcHJvZHVjdGlvblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxDb25zb2xlRXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1lc3NhZ2VzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgc3RyaWN0IG1vZGUgd2FybmluZyBmb3IgdGhlIGZpbmREb21Ob2RlIGNhbGwgYmVsb3dcbiAgICAgICAgICAgICAgICBpZiAoIW1lc3NhZ2VzWzBdLmluY2x1ZGVzKFwiV2FybmluZzogJXMgaXMgZGVwcmVjYXRlZCBpbiBTdHJpY3RNb2RlLlwiKSkge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbENvbnNvbGVFcnJvciguLi5tZXNzYWdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBfcmVhY3Rkb20uZGVmYXVsdC5maW5kRE9NTm9kZShpbnN0YW5jZSk7XG4gICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IgPSBvcmlnaW5hbENvbnNvbGVFcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX3JlYWN0ZG9tLmRlZmF1bHQuZmluZERPTU5vZGUoaW5zdGFuY2UpO1xufVxuY29uc3QgcmVjdFByb3BlcnRpZXMgPSBbXG4gICAgXCJib3R0b21cIixcbiAgICBcImhlaWdodFwiLFxuICAgIFwibGVmdFwiLFxuICAgIFwicmlnaHRcIixcbiAgICBcInRvcFwiLFxuICAgIFwid2lkdGhcIixcbiAgICBcInhcIixcbiAgICBcInlcIlxuXTtcbi8qKlxuICogQ2hlY2sgaWYgYSBIVE1MRWxlbWVudCBpcyBoaWRkZW4uXG4gKi8gZnVuY3Rpb24gZWxlbWVudENhblNjcm9sbChlbGVtZW50KSB7XG4gICAgLy8gVXNlcyBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCB0byBjaGVjayBpZiB0aGUgZWxlbWVudCBpcyBoaWRkZW4gaW5zdGVhZCBvZiBgb2Zmc2V0UGFyZW50YFxuICAgIC8vIGJlY2F1c2UgYG9mZnNldFBhcmVudGAgZG9lc24ndCBjb25zaWRlciBkb2N1bWVudC9ib2R5XG4gICAgY29uc3QgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHJlY3RQcm9wZXJ0aWVzLmV2ZXJ5KChpdGVtKT0+cmVjdFtpdGVtXSA9PT0gMCk7XG59XG4vKipcbiAqIENoZWNrIGlmIHRoZSB0b3AgY29ybmVyIG9mIHRoZSBIVE1MRWxlbWVudCBpcyBpbiB0aGUgdmlld3BvcnQuXG4gKi8gZnVuY3Rpb24gdG9wT2ZFbGVtZW50SW5WaWV3cG9ydChlbGVtZW50LCB2aWV3cG9ydEhlaWdodCkge1xuICAgIGNvbnN0IHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiByZWN0LnRvcCA+PSAwICYmIHJlY3QudG9wIDw9IHZpZXdwb3J0SGVpZ2h0O1xufVxuLyoqXG4gKiBGaW5kIHRoZSBET00gbm9kZSBmb3IgYSBoYXNoIGZyYWdtZW50LlxuICogSWYgYHRvcGAgdGhlIHBhZ2UgaGFzIHRvIHNjcm9sbCB0byB0aGUgdG9wIG9mIHRoZSBwYWdlLiBUaGlzIG1pcnJvcnMgdGhlIGJyb3dzZXIncyBiZWhhdmlvci5cbiAqIElmIHRoZSBoYXNoIGZyYWdtZW50IGlzIGFuIGlkLCB0aGUgcGFnZSBoYXMgdG8gc2Nyb2xsIHRvIHRoZSBlbGVtZW50IHdpdGggdGhhdCBpZC5cbiAqIElmIHRoZSBoYXNoIGZyYWdtZW50IGlzIGEgbmFtZSwgdGhlIHBhZ2UgaGFzIHRvIHNjcm9sbCB0byB0aGUgZmlyc3QgZWxlbWVudCB3aXRoIHRoYXQgbmFtZS5cbiAqLyBmdW5jdGlvbiBnZXRIYXNoRnJhZ21lbnREb21Ob2RlKGhhc2hGcmFnbWVudCkge1xuICAgIC8vIElmIHRoZSBoYXNoIGZyYWdtZW50IGlzIGB0b3BgIHRoZSBwYWdlIGhhcyB0byBzY3JvbGwgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZS5cbiAgICBpZiAoaGFzaEZyYWdtZW50ID09PSBcInRvcFwiKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICAgIH1cbiAgICB2YXIgX2RvY3VtZW50X2dldEVsZW1lbnRCeUlkO1xuICAgIC8vIElmIHRoZSBoYXNoIGZyYWdtZW50IGlzIGFuIGlkLCB0aGUgcGFnZSBoYXMgdG8gc2Nyb2xsIHRvIHRoZSBlbGVtZW50IHdpdGggdGhhdCBpZC5cbiAgICByZXR1cm4gKF9kb2N1bWVudF9nZXRFbGVtZW50QnlJZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2hGcmFnbWVudCkpICE9IG51bGwgPyBfZG9jdW1lbnRfZ2V0RWxlbWVudEJ5SWQgOiAvLyBJZiB0aGUgaGFzaCBmcmFnbWVudCBpcyBhIG5hbWUsIHRoZSBwYWdlIGhhcyB0byBzY3JvbGwgdG8gdGhlIGZpcnN0IGVsZW1lbnQgd2l0aCB0aGF0IG5hbWUuXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoaGFzaEZyYWdtZW50KVswXTtcbn1cbmNsYXNzIElubmVyU2Nyb2xsQW5kRm9jdXNIYW5kbGVyIGV4dGVuZHMgX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50IHtcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVQb3RlbnRpYWxTY3JvbGwoKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICAvLyBCZWNhdXNlIHRoaXMgcHJvcGVydHkgaXMgb3ZlcndyaXR0ZW4gaW4gaGFuZGxlUG90ZW50aWFsU2Nyb2xsIGl0J3MgZmluZSB0byBhbHdheXMgcnVuIGl0IHdoZW4gdHJ1ZSBhcyBpdCdsbCBiZSBzZXQgdG8gZmFsc2UgZm9yIHN1YnNlcXVlbnQgcmVuZGVycy5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZm9jdXNBbmRTY3JvbGxSZWYuYXBwbHkpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUG90ZW50aWFsU2Nyb2xsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLmhhbmRsZVBvdGVudGlhbFNjcm9sbCA9ICgpPT57XG4gICAgICAgICAgICAvLyBIYW5kbGUgc2Nyb2xsIGFuZCBmb2N1cywgaXQncyBvbmx5IGFwcGxpZWQgb25jZSBpbiB0aGUgZmlyc3QgdXNlRWZmZWN0IHRoYXQgdHJpZ2dlcnMgdGhhdCBjaGFuZ2VkLlxuICAgICAgICAgICAgY29uc3QgeyBmb2N1c0FuZFNjcm9sbFJlZiAsIHNlZ21lbnRQYXRoICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmIChmb2N1c0FuZFNjcm9sbFJlZi5hcHBseSkge1xuICAgICAgICAgICAgICAgIC8vIHNlZ21lbnRQYXRocyBpcyBhbiBhcnJheSBvZiBzZWdtZW50IHBhdGhzIHRoYXQgc2hvdWxkIGJlIHNjcm9sbGVkIHRvXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgc2VnbWVudCBwYXRoIGlzIG5vdCBpbiB0aGUgYXJyYXksIHRoZSBzY3JvbGwgaXMgbm90IGFwcGxpZWRcbiAgICAgICAgICAgICAgICAvLyB1bmxlc3MgdGhlIGFycmF5IGlzIGVtcHR5LCBpbiB3aGljaCBjYXNlIHRoZSBzY3JvbGwgaXMgYWx3YXlzIGFwcGxpZWRcbiAgICAgICAgICAgICAgICBpZiAoZm9jdXNBbmRTY3JvbGxSZWYuc2VnbWVudFBhdGhzLmxlbmd0aCAhPT0gMCAmJiAhZm9jdXNBbmRTY3JvbGxSZWYuc2VnbWVudFBhdGhzLnNvbWUoKHNjcm9sbFJlZlNlZ21lbnRQYXRoKT0+c2VnbWVudFBhdGguZXZlcnkoKHNlZ21lbnQsIGluZGV4KT0+KDAsIF9tYXRjaHNlZ21lbnRzLm1hdGNoU2VnbWVudCkoc2VnbWVudCwgc2Nyb2xsUmVmU2VnbWVudFBhdGhbaW5kZXhdKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGRvbU5vZGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc2hGcmFnbWVudCA9IGZvY3VzQW5kU2Nyb2xsUmVmLmhhc2hGcmFnbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoaGFzaEZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbU5vZGUgPSBnZXRIYXNoRnJhZ21lbnREb21Ob2RlKGhhc2hGcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGBmaW5kRE9NTm9kZWAgaXMgdHJpY2t5IGJlY2F1c2UgaXQgcmV0dXJucyBqdXN0IHRoZSBmaXJzdCBjaGlsZCBpZiB0aGUgY29tcG9uZW50IGlzIGEgZnJhZ21lbnQuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBhbHJlYWR5IGNhdXNlZCBhIGJ1ZyB3aGVyZSB0aGUgZmlyc3QgY2hpbGQgd2FzIGEgPGxpbmsvPiBpbiBoZWFkLlxuICAgICAgICAgICAgICAgIGlmICghZG9tTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBkb21Ob2RlID0gZmluZERPTU5vZGUodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgY291bGRuJ3Qgc2VsZWN0IGFueSBET00gbm9kZSwgZXZlbiBoaWdoZXIgdXAgaW4gdGhlIGxheW91dC1yb3V0ZXIgYWJvdmUgdGhlIGN1cnJlbnQgc2VnbWVudFBhdGguXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gRE9NIG5vZGUgdGhpcyBsYXlvdXQtcm91dGVyIGxldmVsIGlzIHNraXBwZWQuIEl0J2xsIGJlIGhhbmRsZWQgaGlnaGVyLXVwIGluIHRoZSB0cmVlLlxuICAgICAgICAgICAgICAgIGlmICghKGRvbU5vZGUgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFZlcmlmeSBpZiB0aGUgZWxlbWVudCBpcyBhIEhUTUxFbGVtZW50IGFuZCBpZiBpdCdzIHZpc2libGUgb24gc2NyZWVuIChlLmcuIG5vdCBkaXNwbGF5OiBub25lKS5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyBub3QgYSBIVE1MRWxlbWVudCBvciBub3QgdmlzaWJsZSB3ZSB0cnkgdG8gc2VsZWN0IHRoZSBuZXh0IHNpYmxpbmcgYW5kIHRyeSBhZ2Fpbi5cbiAgICAgICAgICAgICAgICB3aGlsZSghKGRvbU5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgfHwgZWxlbWVudENhblNjcm9sbChkb21Ob2RlKSl7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgY291bGRuJ3Qgc2VsZWN0IGFueSBET00gbm9kZSwgZXZlbiBoaWdoZXIgdXAgaW4gdGhlIGxheW91dC1yb3V0ZXIgYWJvdmUgdGhlIGN1cnJlbnQgc2VnbWVudFBhdGguXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIHNpYmxpbmdzIGZvdW5kIHRoYXQgYXJlIHZpc2libGUgc28gd2UgaGFuZGxlIHNjcm9sbCBoaWdoZXIgdXAgaW4gdGhlIHRyZWUgaW5zdGVhZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbU5vZGUubmV4dEVsZW1lbnRTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZG9tTm9kZSA9IGRvbU5vZGUubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTdGF0ZSBpcyBtdXRhdGVkIHRvIGVuc3VyZSB0aGF0IHRoZSBmb2N1cyBhbmQgc2Nyb2xsIGlzIGFwcGxpZWQgb25seSBvbmNlLlxuICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmLmFwcGx5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWYuaGFzaEZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZi5zZWdtZW50UGF0aHMgPSBbXTtcbiAgICAgICAgICAgICAgICAoMCwgX2hhbmRsZXNtb290aHNjcm9sbC5oYW5kbGVTbW9vdGhTY3JvbGwpKCgpPT57XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIGNhc2Ugb2YgaGFzaCBzY3JvbGwgd2UgbmVlZCB0byBzY3JvbGwgdG8gdGhlIHRvcCBvZiB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzaEZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgZG9tTm9kZS5vZmZzZXRUb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBjdXJyZW50IHZpZXdwb3J0IGhlaWdodCBiZWNhdXNlIHJlYWRpbmcgYGNsaWVudEhlaWdodGAgY2F1c2VzIGEgcmVmbG93LFxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgaXQgd29uJ3QgY2hhbmdlIGR1cmluZyB0aGlzIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBodG1sRWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgdmlld3BvcnRIZWlnaHQgPSBodG1sRWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBlbGVtZW50J3MgdG9wIGVkZ2UgaXMgYWxyZWFkeSBpbiB0aGUgdmlld3BvcnQsIGV4aXQgZWFybHkuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3BPZkVsZW1lbnRJblZpZXdwb3J0KGRvbU5vZGUsIHZpZXdwb3J0SGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdHJ5IHNjcm9sbGluZyBnbyB0aGUgdG9wIG9mIHRoZSBkb2N1bWVudCB0byBiZSBiYWNrd2FyZCBjb21wYXRpYmxlIHdpdGggcGFnZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc2Nyb2xsSW50b1ZpZXcoKSBjYWxsZWQgb24gYDxodG1sLz5gIGVsZW1lbnQgc2Nyb2xscyBob3Jpem9udGFsbHkgb24gY2hyb21lIGFuZCBmaXJlZm94ICh0aGF0IHNob3VsZG4ndCBoYXBwZW4pXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGNvdWxkIHVzZSBpdCB0byBzY3JvbGwgaG9yaXpvbnRhbGx5IGZvbGxvd2luZyBSVEwgYnV0IHRoYXQgYWxzbyBzZWVtcyB0byBiZSBicm9rZW4gLSBpdCB3aWxsIGFsd2F5cyBzY3JvbGwgbGVmdFxuICAgICAgICAgICAgICAgICAgICAvLyBzY3JvbGxMZWZ0ID0gMCBhbHNvIHNlZW1zIHRvIGlnbm9yZSBSVEwgYW5kIG1hbnVhbGx5IGNoZWNraW5nIGZvciBSVEwgaXMgdG9vIG11Y2ggaGFzc2xlIHNvIHdlIHdpbGwgc2Nyb2xsIGp1c3QgdmVydGljYWxseVxuICAgICAgICAgICAgICAgICAgICBodG1sRWxlbWVudC5zY3JvbGxUb3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICAvLyBTY3JvbGwgdG8gZG9tTm9kZSBpZiBkb21Ob2RlIGlzIG5vdCBpbiB2aWV3cG9ydCB3aGVuIHNjcm9sbGVkIHRvIHRvcCBvZiBkb2N1bWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRvcE9mRWxlbWVudEluVmlld3BvcnQoZG9tTm9kZSwgdmlld3BvcnRIZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21Ob2RlLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHdpbGwgZm9yY2UgbGF5b3V0IGJ5IHF1ZXJ5aW5nIGRvbU5vZGUgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgZG9udEZvcmNlTGF5b3V0OiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gU2V0IGZvY3VzIG9uIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgZG9tTm9kZS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIFNjcm9sbEFuZEZvY3VzSGFuZGxlcihwYXJhbSkge1xuICAgIGxldCB7IHNlZ21lbnRQYXRoICwgY2hpbGRyZW4gIH0gPSBwYXJhbTtcbiAgICBjb25zdCBjb250ZXh0ID0gKDAsIF9yZWFjdC51c2VDb250ZXh0KShfYXBwcm91dGVyY29udGV4dC5HbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0KTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YXJpYW50IGdsb2JhbCBsYXlvdXQgcm91dGVyIG5vdCBtb3VudGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KElubmVyU2Nyb2xsQW5kRm9jdXNIYW5kbGVyLCB7XG4gICAgICAgIHNlZ21lbnRQYXRoOiBzZWdtZW50UGF0aCxcbiAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IGNvbnRleHQuZm9jdXNBbmRTY3JvbGxSZWZcbiAgICB9LCBjaGlsZHJlbik7XG59XG4vKipcbiAqIElubmVyTGF5b3V0Um91dGVyIGhhbmRsZXMgcmVuZGVyaW5nIHRoZSBwcm92aWRlZCBzZWdtZW50IGJhc2VkIG9uIHRoZSBjYWNoZS5cbiAqLyBmdW5jdGlvbiBJbm5lckxheW91dFJvdXRlcihwYXJhbSkge1xuICAgIGxldCB7IHBhcmFsbGVsUm91dGVyS2V5ICwgdXJsICwgY2hpbGROb2RlcyAsIGNoaWxkUHJvcCAsIHNlZ21lbnRQYXRoICwgdHJlZSAsIC8vIFRPRE8tQVBQOiBpbXBsZW1lbnQgYDxPZmZzY3JlZW4+YCB3aGVuIGF2YWlsYWJsZS5cbiAgICAvLyBpc0FjdGl2ZSxcbiAgICBjYWNoZUtleSAgfSA9IHBhcmFtO1xuICAgIGNvbnN0IGNvbnRleHQgPSAoMCwgX3JlYWN0LnVzZUNvbnRleHQpKF9hcHByb3V0ZXJjb250ZXh0Lkdsb2JhbExheW91dFJvdXRlckNvbnRleHQpO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhcmlhbnQgZ2xvYmFsIGxheW91dCByb3V0ZXIgbm90IG1vdW50ZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IHsgY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZSAsIHRyZWU6IGZ1bGxUcmVlICB9ID0gY29udGV4dDtcbiAgICAvLyBSZWFkIHNlZ21lbnQgcGF0aCBmcm9tIHRoZSBwYXJhbGxlbCByb3V0ZXIgY2FjaGUgbm9kZS5cbiAgICBsZXQgY2hpbGROb2RlID0gY2hpbGROb2Rlcy5nZXQoY2FjaGVLZXkpO1xuICAgIC8vIElmIGNoaWxkUHJvcCBpcyBhdmFpbGFibGUgdGhpcyBtZWFucyBpdCdzIHRoZSBGbGlnaHQgLyBTU1IgY2FzZS5cbiAgICBpZiAoY2hpbGRQcm9wICYmIC8vIFRPRE8tQVBQOiB2ZXJpZnkgaWYgdGhpcyBjYW4gYmUgbnVsbCBiYXNlZCBvbiB1c2VyIGNvZGVcbiAgICBjaGlsZFByb3AuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIWNoaWxkTm9kZSkge1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBzZWdtZW50J3Mgc3ViVHJlZURhdGEgdG8gdGhlIGNhY2hlLlxuICAgICAgICAgICAgLy8gVGhpcyB3cml0ZXMgdG8gdGhlIGNhY2hlIHdoZW4gdGhlcmUgaXMgbm8gaXRlbSBpbiB0aGUgY2FjaGUgeWV0LiBJdCBuZXZlciAqb3ZlcndyaXRlcyogZXhpc3RpbmcgY2FjaGUgaXRlbXMgd2hpY2ggaXMgd2h5IGl0J3Mgc2FmZSBpbiBjb25jdXJyZW50IG1vZGUuXG4gICAgICAgICAgICBjaGlsZE5vZGVzLnNldChjYWNoZUtleSwge1xuICAgICAgICAgICAgICAgIHN0YXR1czogX2FwcHJvdXRlcmNvbnRleHQuQ2FjaGVTdGF0ZXMuUkVBRFksXG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogY2hpbGRQcm9wLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBJbiB0aGUgYWJvdmUgY2FzZSBjaGlsZE5vZGUgd2FzIHNldCBvbiBjaGlsZE5vZGVzLCBzbyB3ZSBoYXZlIHRvIGdldCBpdCBmcm9tIHRoZSBjYWNoZU5vZGVzIGFnYWluLlxuICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlcy5nZXQoY2FjaGVLZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5zdGF0dXMgPT09IF9hcHByb3V0ZXJjb250ZXh0LkNhY2hlU3RhdGVzLkxBWllfSU5JVElBTElaRUQpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHdlJ3JlIGNoYW5naW5nIGl0J3MgdHlwZSFcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGUuc3RhdHVzID0gX2FwcHJvdXRlcmNvbnRleHQuQ2FjaGVTdGF0ZXMuUkVBRFk7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5zdWJUcmVlRGF0YSA9IGNoaWxkUHJvcC5jdXJyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFdoZW4gY2hpbGROb2RlIGlzIG5vdCBhdmFpbGFibGUgZHVyaW5nIHJlbmRlcmluZyBjbGllbnQtc2lkZSB3ZSBuZWVkIHRvIGZldGNoIGl0IGZyb20gdGhlIHNlcnZlci5cbiAgICBpZiAoIWNoaWxkTm9kZSB8fCBjaGlsZE5vZGUuc3RhdHVzID09PSBfYXBwcm91dGVyY29udGV4dC5DYWNoZVN0YXRlcy5MQVpZX0lOSVRJQUxJWkVEKSB7XG4gICAgICAgIC8qKlxuICAgICAqIFJvdXRlciBzdGF0ZSB3aXRoIHJlZmV0Y2ggbWFya2VyIGFkZGVkXG4gICAgICovIC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgY29uc3QgcmVmZXRjaFRyZWUgPSB3YWxrQWRkUmVmZXRjaChbXG4gICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgLi4uc2VnbWVudFBhdGhcbiAgICAgICAgXSwgZnVsbFRyZWUpO1xuICAgICAgICAvKipcbiAgICAgKiBGbGlnaHQgZGF0YSBmZXRjaCBraWNrZWQgb2ZmIGR1cmluZyByZW5kZXIgYW5kIHB1dCBpbnRvIHRoZSBjYWNoZS5cbiAgICAgKi8gY2hpbGROb2Rlcy5zZXQoY2FjaGVLZXksIHtcbiAgICAgICAgICAgIHN0YXR1czogX2FwcHJvdXRlcmNvbnRleHQuQ2FjaGVTdGF0ZXMuREFUQV9GRVRDSCxcbiAgICAgICAgICAgIGRhdGE6ICgwLCBfZmV0Y2hzZXJ2ZXJyZXNwb25zZS5mZXRjaFNlcnZlclJlc3BvbnNlKShuZXcgVVJMKHVybCwgbG9jYXRpb24ub3JpZ2luKSwgcmVmZXRjaFRyZWUsIGNvbnRleHQubmV4dFVybCksXG4gICAgICAgICAgICBzdWJUcmVlRGF0YTogbnVsbCxcbiAgICAgICAgICAgIGhlYWQ6IGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuc3RhdHVzID09PSBfYXBwcm91dGVyY29udGV4dC5DYWNoZVN0YXRlcy5MQVpZX0lOSVRJQUxJWkVEID8gY2hpbGROb2RlLmhlYWQgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogY2hpbGROb2RlICYmIGNoaWxkTm9kZS5zdGF0dXMgPT09IF9hcHByb3V0ZXJjb250ZXh0LkNhY2hlU3RhdGVzLkxBWllfSU5JVElBTElaRUQgPyBjaGlsZE5vZGUucGFyYWxsZWxSb3V0ZXMgOiBuZXcgTWFwKClcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEluIHRoZSBhYm92ZSBjYXNlIGNoaWxkTm9kZSB3YXMgc2V0IG9uIGNoaWxkTm9kZXMsIHNvIHdlIGhhdmUgdG8gZ2V0IGl0IGZyb20gdGhlIGNhY2hlTm9kZXMgYWdhaW4uXG4gICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXMuZ2V0KGNhY2hlS2V5KTtcbiAgICB9XG4gICAgLy8gVGhpcyBjYXNlIHNob3VsZCBuZXZlciBoYXBwZW4gc28gaXQgdGhyb3dzIGFuIGVycm9yLiBJdCBpbmRpY2F0ZXMgdGhlcmUncyBhIGJ1ZyBpbiB0aGUgTmV4dC5qcy5cbiAgICBpZiAoIWNoaWxkTm9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZCBub2RlIHNob3VsZCBhbHdheXMgZXhpc3RcIik7XG4gICAgfVxuICAgIC8vIFRoaXMgY2FzZSBzaG91bGQgbmV2ZXIgaGFwcGVuIHNvIGl0IHRocm93cyBhbiBlcnJvci4gSXQgaW5kaWNhdGVzIHRoZXJlJ3MgYSBidWcgaW4gdGhlIE5leHQuanMuXG4gICAgaWYgKGNoaWxkTm9kZS5zdWJUcmVlRGF0YSAmJiBjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZCBub2RlIHNob3VsZCBub3QgaGF2ZSBib3RoIHN1YlRyZWVEYXRhIGFuZCBkYXRhXCIpO1xuICAgIH1cbiAgICAvLyBJZiBjYWNoZSBub2RlIGhhcyBhIGRhdGEgcmVxdWVzdCB3ZSBoYXZlIHRvIHVud3JhcCByZXNwb25zZSBieSBgdXNlYCBhbmQgdXBkYXRlIHRoZSBjYWNoZS5cbiAgICBpZiAoY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgICAgLyoqXG4gICAgICogRmxpZ2h0IHJlc3BvbnNlIGRhdGFcbiAgICAgKi8gLy8gV2hlbiB0aGUgZGF0YSBoYXMgbm90IHJlc29sdmVkIHlldCBgdXNlYCB3aWxsIHN1c3BlbmQgaGVyZS5cbiAgICAgICAgY29uc3QgW2ZsaWdodERhdGEsIG92ZXJyaWRlQ2Fub25pY2FsVXJsXSA9ICgwLCBfcmVhY3QudXNlKShjaGlsZE5vZGUuZGF0YSk7XG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gbmF2aWdhdGluZyB0byBwYWdlIGluIGBwYWdlc2AgZnJvbSBgYXBwYFxuICAgICAgICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2VnbWVudFBhdGggZnJvbSB0aGUgc2VydmVyIGRvZXMgbm90IG1hdGNoIHRoZSBsYXlvdXQncyBzZWdtZW50UGF0aFxuICAgICAgICBjaGlsZE5vZGUuZGF0YSA9IG51bGw7XG4gICAgICAgIC8vIHNldFRpbWVvdXQgaXMgdXNlZCB0byBzdGFydCBhIG5ldyB0cmFuc2l0aW9uIGR1cmluZyByZW5kZXIsIHRoaXMgaXMgYW4gaW50ZW50aW9uYWwgaGFjayBhcm91bmQgUmVhY3QuXG4gICAgICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgc3RhcnRUcmFuc2l0aW9uIGV4aXN0c1xuICAgICAgICAgICAgX3JlYWN0LmRlZmF1bHQuc3RhcnRUcmFuc2l0aW9uKCgpPT57XG4gICAgICAgICAgICAgICAgY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZShmdWxsVHJlZSwgZmxpZ2h0RGF0YSwgb3ZlcnJpZGVDYW5vbmljYWxVcmwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTdXNwZW5kIGluZmluaXRlbHkgYXMgYGNoYW5nZUJ5U2VydmVyUmVzcG9uc2VgIHdpbGwgY2F1c2UgYSBkaWZmZXJlbnQgcGFydCBvZiB0aGUgdHJlZSB0byBiZSByZW5kZXJlZC5cbiAgICAgICAgKDAsIF9yZWFjdC51c2UpKCgwLCBfaW5maW5pdGVwcm9taXNlLmNyZWF0ZUluZmluaXRlUHJvbWlzZSkoKSk7XG4gICAgfVxuICAgIC8vIElmIGNhY2hlIG5vZGUgaGFzIG5vIHN1YlRyZWVEYXRhIGFuZCBubyBkYXRhIHJlcXVlc3Qgd2UgaGF2ZSB0byBpbmZpbml0ZWx5IHN1c3BlbmQgYXMgdGhlIGRhdGEgd2lsbCBsaWtlbHkgZmxvdyBpbiBmcm9tIGFub3RoZXIgcGxhY2UuXG4gICAgLy8gVE9ETy1BUFA6IGRvdWJsZSBjaGVjayB1c2VycyBjYW4ndCByZXR1cm4gbnVsbCBpbiBhIGNvbXBvbmVudCB0aGF0IHdpbGwga2ljayBpbiBoZXJlLlxuICAgIGlmICghY2hpbGROb2RlLnN1YlRyZWVEYXRhKSB7XG4gICAgICAgICgwLCBfcmVhY3QudXNlKSgoMCwgX2luZmluaXRlcHJvbWlzZS5jcmVhdGVJbmZpbml0ZVByb21pc2UpKCkpO1xuICAgIH1cbiAgICBjb25zdCBzdWJ0cmVlID0gLy8gVGhlIGxheW91dCByb3V0ZXIgY29udGV4dCBuYXJyb3dzIGRvd24gdHJlZSBhbmQgY2hpbGROb2RlcyBhdCBlYWNoIGxldmVsLlxuICAgIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfYXBwcm91dGVyY29udGV4dC5MYXlvdXRSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0cmVlOiB0cmVlWzFdW3BhcmFsbGVsUm91dGVyS2V5XSxcbiAgICAgICAgICAgIGNoaWxkTm9kZXM6IGNoaWxkTm9kZS5wYXJhbGxlbFJvdXRlcyxcbiAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBvdmVycmlkaW5nIG9mIHVybCBmb3IgcGFyYWxsZWwgcm91dGVzXG4gICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICB9XG4gICAgfSwgY2hpbGROb2RlLnN1YlRyZWVEYXRhKTtcbiAgICAvLyBFbnN1cmUgcm9vdCBsYXlvdXQgaXMgbm90IHdyYXBwZWQgaW4gYSBkaXYgYXMgdGhlIHJvb3QgbGF5b3V0IHJlbmRlcnMgYDxodG1sPmBcbiAgICByZXR1cm4gc3VidHJlZTtcbn1cbi8qKlxuICogUmVuZGVycyBzdXNwZW5zZSBib3VuZGFyeSB3aXRoIHRoZSBwcm92aWRlZCBcImxvYWRpbmdcIiBwcm9wZXJ0eSBhcyB0aGUgZmFsbGJhY2suXG4gKiBJZiBubyBsb2FkaW5nIHByb3BlcnR5IGlzIHByb3ZpZGVkIGl0IHJlbmRlcnMgdGhlIGNoaWxkcmVuIHdpdGhvdXQgYSBzdXNwZW5zZSBib3VuZGFyeS5cbiAqLyBmdW5jdGlvbiBMb2FkaW5nQm91bmRhcnkocGFyYW0pIHtcbiAgICBsZXQgeyBjaGlsZHJlbiAsIGxvYWRpbmcgLCBsb2FkaW5nU3R5bGVzICwgaGFzTG9hZGluZyAgfSA9IHBhcmFtO1xuICAgIGlmIChoYXNMb2FkaW5nKSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuU3VzcGVuc2UsIHtcbiAgICAgICAgICAgIGZhbGxiYWNrOiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIGxvYWRpbmdTdHlsZXMsIGxvYWRpbmcpXG4gICAgICAgIH0sIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gT3V0ZXJMYXlvdXRSb3V0ZXIocGFyYW0pIHtcbiAgICBsZXQgeyBwYXJhbGxlbFJvdXRlcktleSAsIHNlZ21lbnRQYXRoICwgY2hpbGRQcm9wICwgZXJyb3IgLCBlcnJvclN0eWxlcyAsIHRlbXBsYXRlU3R5bGVzICwgbG9hZGluZyAsIGxvYWRpbmdTdHlsZXMgLCBoYXNMb2FkaW5nICwgdGVtcGxhdGUgLCBub3RGb3VuZCAsIG5vdEZvdW5kU3R5bGVzICwgYXNOb3RGb3VuZCAsIHN0eWxlcyAgfSA9IHBhcmFtO1xuICAgIGNvbnN0IGNvbnRleHQgPSAoMCwgX3JlYWN0LnVzZUNvbnRleHQpKF9hcHByb3V0ZXJjb250ZXh0LkxheW91dFJvdXRlckNvbnRleHQpO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhcmlhbnQgZXhwZWN0ZWQgbGF5b3V0IHJvdXRlciB0byBiZSBtb3VudGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGNoaWxkTm9kZXMgLCB0cmVlICwgdXJsICB9ID0gY29udGV4dDtcbiAgICAvLyBHZXQgdGhlIGN1cnJlbnQgcGFyYWxsZWxSb3V0ZXIgY2FjaGUgbm9kZVxuICAgIGxldCBjaGlsZE5vZGVzRm9yUGFyYWxsZWxSb3V0ZXIgPSBjaGlsZE5vZGVzLmdldChwYXJhbGxlbFJvdXRlcktleSk7XG4gICAgLy8gSWYgdGhlIHBhcmFsbGVsIHJvdXRlciBjYWNoZSBub2RlIGRvZXMgbm90IGV4aXN0IHlldCwgY3JlYXRlIGl0LlxuICAgIC8vIFRoaXMgd3JpdGVzIHRvIHRoZSBjYWNoZSB3aGVuIHRoZXJlIGlzIG5vIGl0ZW0gaW4gdGhlIGNhY2hlIHlldC4gSXQgbmV2ZXIgKm92ZXJ3cml0ZXMqIGV4aXN0aW5nIGNhY2hlIGl0ZW1zIHdoaWNoIGlzIHdoeSBpdCdzIHNhZmUgaW4gY29uY3VycmVudCBtb2RlLlxuICAgIGlmICghY2hpbGROb2Rlc0ZvclBhcmFsbGVsUm91dGVyKSB7XG4gICAgICAgIGNoaWxkTm9kZXMuc2V0KHBhcmFsbGVsUm91dGVyS2V5LCBuZXcgTWFwKCkpO1xuICAgICAgICBjaGlsZE5vZGVzRm9yUGFyYWxsZWxSb3V0ZXIgPSBjaGlsZE5vZGVzLmdldChwYXJhbGxlbFJvdXRlcktleSk7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgYWN0aXZlIHNlZ21lbnQgaW4gdGhlIHRyZWVcbiAgICAvLyBUaGUgcmVhc29uIGFycmF5cyBhcmUgdXNlZCBpbiB0aGUgZGF0YSBmb3JtYXQgaXMgdGhhdCB0aGVzZSBhcmUgdHJhbnNmZXJyZWQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBicm93c2VyIHNvIGl0J3Mgb3B0aW1pemVkIHRvIHNhdmUgYnl0ZXMuXG4gICAgY29uc3QgdHJlZVNlZ21lbnQgPSB0cmVlWzFdW3BhcmFsbGVsUm91dGVyS2V5XVswXTtcbiAgICBjb25zdCBjaGlsZFByb3BTZWdtZW50ID0gY2hpbGRQcm9wLnNlZ21lbnQ7XG4gICAgLy8gSWYgc2VnbWVudCBpcyBhbiBhcnJheSBpdCdzIGEgZHluYW1pYyByb3V0ZSBhbmQgd2Ugd2FudCB0byByZWFkIHRoZSBkeW5hbWljIHJvdXRlIHZhbHVlIGFzIHRoZSBzZWdtZW50IHRvIGdldCBmcm9tIHRoZSBjYWNoZS5cbiAgICBjb25zdCBjdXJyZW50Q2hpbGRTZWdtZW50VmFsdWUgPSAoMCwgX2dldHNlZ21lbnR2YWx1ZS5nZXRTZWdtZW50VmFsdWUpKHRyZWVTZWdtZW50KTtcbiAgICAvKipcbiAgICogRGVjaWRlcyB3aGljaCBzZWdtZW50cyB0byBrZWVwIHJlbmRlcmluZywgYWxsIHNlZ21lbnRzIHRoYXQgYXJlIG5vdCBhY3RpdmUgd2lsbCBiZSB3cmFwcGVkIGluIGA8T2Zmc2NyZWVuPmAuXG4gICAqLyAvLyBUT0RPLUFQUDogQWRkIGhhbmRsaW5nIG9mIGA8T2Zmc2NyZWVuPmAgd2hlbiBpdCdzIGF2YWlsYWJsZS5cbiAgICBjb25zdCBwcmVzZXJ2ZWRTZWdtZW50cyA9IFtcbiAgICAgICAgdHJlZVNlZ21lbnRcbiAgICBdO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIHN0eWxlcywgcHJlc2VydmVkU2VnbWVudHMubWFwKChwcmVzZXJ2ZWRTZWdtZW50KT0+e1xuICAgICAgICBjb25zdCBpc0NoaWxkUHJvcFNlZ21lbnQgPSAoMCwgX21hdGNoc2VnbWVudHMubWF0Y2hTZWdtZW50KShwcmVzZXJ2ZWRTZWdtZW50LCBjaGlsZFByb3BTZWdtZW50KTtcbiAgICAgICAgY29uc3QgcHJlc2VydmVkU2VnbWVudFZhbHVlID0gKDAsIF9nZXRzZWdtZW50dmFsdWUuZ2V0U2VnbWVudFZhbHVlKShwcmVzZXJ2ZWRTZWdtZW50KTtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSAoMCwgX2NyZWF0ZXJvdXRlcmNhY2hla2V5LmNyZWF0ZVJvdXRlckNhY2hlS2V5KShwcmVzZXJ2ZWRTZWdtZW50KTtcbiAgICAgICAgcmV0dXJuKC8qXG4gICAgICAgICAgICAtIEVycm9yIGJvdW5kYXJ5XG4gICAgICAgICAgICAgIC0gT25seSByZW5kZXJzIGVycm9yIGJvdW5kYXJ5IGlmIGVycm9yIGNvbXBvbmVudCBpcyBwcm92aWRlZC5cbiAgICAgICAgICAgICAgLSBSZW5kZXJlZCBmb3IgZWFjaCBzZWdtZW50IHRvIGVuc3VyZSB0aGV5IGhhdmUgdGhlaXIgb3duIGVycm9yIHN0YXRlLlxuICAgICAgICAgICAgLSBMb2FkaW5nIGJvdW5kYXJ5XG4gICAgICAgICAgICAgIC0gT25seSByZW5kZXJzIHN1c3BlbnNlIGJvdW5kYXJ5IGlmIGxvYWRpbmcgY29tcG9uZW50cyBpcyBwcm92aWRlZC5cbiAgICAgICAgICAgICAgLSBSZW5kZXJlZCBmb3IgZWFjaCBzZWdtZW50IHRvIGVuc3VyZSB0aGV5IGhhdmUgdGhlaXIgb3duIGxvYWRpbmcgc3RhdGUuXG4gICAgICAgICAgICAgIC0gUGFzc2VkIHRvIHRoZSByb3V0ZXIgZHVyaW5nIHJlbmRlcmluZyB0byBlbnN1cmUgaXQgY2FuIGJlIGltbWVkaWF0ZWx5IHJlbmRlcmVkIHdoZW4gc3VzcGVuZGluZyBvbiBhIEZsaWdodCBmZXRjaC5cbiAgICAgICAgICAqLyAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2FwcHJvdXRlcmNvbnRleHQuVGVtcGxhdGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgICAgICBrZXk6ICgwLCBfY3JlYXRlcm91dGVyY2FjaGVrZXkuY3JlYXRlUm91dGVyQ2FjaGVLZXkpKHByZXNlcnZlZFNlZ21lbnQsIHRydWUpLFxuICAgICAgICAgICAgdmFsdWU6IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChTY3JvbGxBbmRGb2N1c0hhbmRsZXIsIHtcbiAgICAgICAgICAgICAgICBzZWdtZW50UGF0aDogc2VnbWVudFBhdGhcbiAgICAgICAgICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfZXJyb3Jib3VuZGFyeS5FcnJvckJvdW5kYXJ5LCB7XG4gICAgICAgICAgICAgICAgZXJyb3JDb21wb25lbnQ6IGVycm9yLFxuICAgICAgICAgICAgICAgIGVycm9yU3R5bGVzOiBlcnJvclN0eWxlc1xuICAgICAgICAgICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KExvYWRpbmdCb3VuZGFyeSwge1xuICAgICAgICAgICAgICAgIGhhc0xvYWRpbmc6IGhhc0xvYWRpbmcsXG4gICAgICAgICAgICAgICAgbG9hZGluZzogbG9hZGluZyxcbiAgICAgICAgICAgICAgICBsb2FkaW5nU3R5bGVzOiBsb2FkaW5nU3R5bGVzXG4gICAgICAgICAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX25vdGZvdW5kYm91bmRhcnkuTm90Rm91bmRCb3VuZGFyeSwge1xuICAgICAgICAgICAgICAgIG5vdEZvdW5kOiBub3RGb3VuZCxcbiAgICAgICAgICAgICAgICBub3RGb3VuZFN0eWxlczogbm90Rm91bmRTdHlsZXMsXG4gICAgICAgICAgICAgICAgYXNOb3RGb3VuZDogYXNOb3RGb3VuZFxuICAgICAgICAgICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWRpcmVjdGJvdW5kYXJ5LlJlZGlyZWN0Qm91bmRhcnksIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChJbm5lckxheW91dFJvdXRlciwge1xuICAgICAgICAgICAgICAgIHBhcmFsbGVsUm91dGVyS2V5OiBwYXJhbGxlbFJvdXRlcktleSxcbiAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICB0cmVlOiB0cmVlLFxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IGNoaWxkTm9kZXNGb3JQYXJhbGxlbFJvdXRlcixcbiAgICAgICAgICAgICAgICBjaGlsZFByb3A6IGlzQ2hpbGRQcm9wU2VnbWVudCA/IGNoaWxkUHJvcCA6IG51bGwsXG4gICAgICAgICAgICAgICAgc2VnbWVudFBhdGg6IHNlZ21lbnRQYXRoLFxuICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBjYWNoZUtleSxcbiAgICAgICAgICAgICAgICBpc0FjdGl2ZTogY3VycmVudENoaWxkU2VnbWVudFZhbHVlID09PSBwcmVzZXJ2ZWRTZWdtZW50VmFsdWVcbiAgICAgICAgICAgIH0pKSkpKSlcbiAgICAgICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCB0ZW1wbGF0ZVN0eWxlcywgdGVtcGxhdGUpKSk7XG4gICAgfSkpO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYXlvdXQtcm91dGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJPdXRlckxheW91dFJvdXRlciIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwiX3JlYWN0IiwiXyIsIl9yZWFjdGRvbSIsIl9hcHByb3V0ZXJjb250ZXh0IiwiX2ZldGNoc2VydmVycmVzcG9uc2UiLCJfaW5maW5pdGVwcm9taXNlIiwiX2Vycm9yYm91bmRhcnkiLCJfbWF0Y2hzZWdtZW50cyIsIl9oYW5kbGVzbW9vdGhzY3JvbGwiLCJfcmVkaXJlY3Rib3VuZGFyeSIsIl9ub3Rmb3VuZGJvdW5kYXJ5IiwiX2dldHNlZ21lbnR2YWx1ZSIsIl9jcmVhdGVyb3V0ZXJjYWNoZWtleSIsIndhbGtBZGRSZWZldGNoIiwic2VnbWVudFBhdGhUb1dhbGsiLCJ0cmVlVG9SZWNyZWF0ZSIsInNlZ21lbnQiLCJwYXJhbGxlbFJvdXRlS2V5IiwiaXNMYXN0IiwibGVuZ3RoIiwibWF0Y2hTZWdtZW50IiwiaGFzT3duUHJvcGVydHkiLCJzdWJUcmVlIiwidW5kZWZpbmVkIiwic2xpY2UiLCJmaW5kRE9NTm9kZSIsImluc3RhbmNlIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwib3JpZ2luYWxDb25zb2xlRXJyb3IiLCJjb25zb2xlIiwiZXJyb3IiLCJfbGVuIiwiYXJndW1lbnRzIiwibWVzc2FnZXMiLCJBcnJheSIsIl9rZXkiLCJpbmNsdWRlcyIsImRlZmF1bHQiLCJyZWN0UHJvcGVydGllcyIsImVsZW1lbnRDYW5TY3JvbGwiLCJlbGVtZW50IiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImV2ZXJ5IiwiaXRlbSIsInRvcE9mRWxlbWVudEluVmlld3BvcnQiLCJ2aWV3cG9ydEhlaWdodCIsInRvcCIsImdldEhhc2hGcmFnbWVudERvbU5vZGUiLCJoYXNoRnJhZ21lbnQiLCJkb2N1bWVudCIsImJvZHkiLCJfZG9jdW1lbnRfZ2V0RWxlbWVudEJ5SWQiLCJnZXRFbGVtZW50QnlJZCIsImdldEVsZW1lbnRzQnlOYW1lIiwiSW5uZXJTY3JvbGxBbmRGb2N1c0hhbmRsZXIiLCJDb21wb25lbnQiLCJjb21wb25lbnREaWRNb3VudCIsImhhbmRsZVBvdGVudGlhbFNjcm9sbCIsImNvbXBvbmVudERpZFVwZGF0ZSIsInByb3BzIiwiZm9jdXNBbmRTY3JvbGxSZWYiLCJhcHBseSIsInJlbmRlciIsImNoaWxkcmVuIiwiY29uc3RydWN0b3IiLCJhcmdzIiwic2VnbWVudFBhdGgiLCJzZWdtZW50UGF0aHMiLCJzb21lIiwic2Nyb2xsUmVmU2VnbWVudFBhdGgiLCJpbmRleCIsImRvbU5vZGUiLCJFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJuZXh0RWxlbWVudFNpYmxpbmciLCJoYW5kbGVTbW9vdGhTY3JvbGwiLCJ3aW5kb3ciLCJzY3JvbGxUbyIsIm9mZnNldFRvcCIsImh0bWxFbGVtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiY2xpZW50SGVpZ2h0Iiwic2Nyb2xsVG9wIiwic2Nyb2xsSW50b1ZpZXciLCJkb250Rm9yY2VMYXlvdXQiLCJmb2N1cyIsIlNjcm9sbEFuZEZvY3VzSGFuZGxlciIsInBhcmFtIiwiY29udGV4dCIsInVzZUNvbnRleHQiLCJHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0IiwiRXJyb3IiLCJjcmVhdGVFbGVtZW50IiwiSW5uZXJMYXlvdXRSb3V0ZXIiLCJwYXJhbGxlbFJvdXRlcktleSIsInVybCIsImNoaWxkTm9kZXMiLCJjaGlsZFByb3AiLCJ0cmVlIiwiY2FjaGVLZXkiLCJjaGFuZ2VCeVNlcnZlclJlc3BvbnNlIiwiZnVsbFRyZWUiLCJjaGlsZE5vZGUiLCJjdXJyZW50Iiwic2V0Iiwic3RhdHVzIiwiQ2FjaGVTdGF0ZXMiLCJSRUFEWSIsImRhdGEiLCJzdWJUcmVlRGF0YSIsInBhcmFsbGVsUm91dGVzIiwiTWFwIiwiTEFaWV9JTklUSUFMSVpFRCIsInJlZmV0Y2hUcmVlIiwiREFUQV9GRVRDSCIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJVUkwiLCJsb2NhdGlvbiIsIm9yaWdpbiIsIm5leHRVcmwiLCJoZWFkIiwiZmxpZ2h0RGF0YSIsIm92ZXJyaWRlQ2Fub25pY2FsVXJsIiwidXNlIiwiaHJlZiIsInNldFRpbWVvdXQiLCJzdGFydFRyYW5zaXRpb24iLCJjcmVhdGVJbmZpbml0ZVByb21pc2UiLCJzdWJ0cmVlIiwiTGF5b3V0Um91dGVyQ29udGV4dCIsIlByb3ZpZGVyIiwiTG9hZGluZ0JvdW5kYXJ5IiwibG9hZGluZyIsImxvYWRpbmdTdHlsZXMiLCJoYXNMb2FkaW5nIiwiU3VzcGVuc2UiLCJmYWxsYmFjayIsIkZyYWdtZW50IiwiZXJyb3JTdHlsZXMiLCJ0ZW1wbGF0ZVN0eWxlcyIsInRlbXBsYXRlIiwibm90Rm91bmQiLCJub3RGb3VuZFN0eWxlcyIsImFzTm90Rm91bmQiLCJzdHlsZXMiLCJjaGlsZE5vZGVzRm9yUGFyYWxsZWxSb3V0ZXIiLCJ0cmVlU2VnbWVudCIsImNoaWxkUHJvcFNlZ21lbnQiLCJjdXJyZW50Q2hpbGRTZWdtZW50VmFsdWUiLCJnZXRTZWdtZW50VmFsdWUiLCJwcmVzZXJ2ZWRTZWdtZW50cyIsIm1hcCIsInByZXNlcnZlZFNlZ21lbnQiLCJpc0NoaWxkUHJvcFNlZ21lbnQiLCJwcmVzZXJ2ZWRTZWdtZW50VmFsdWUiLCJjcmVhdGVSb3V0ZXJDYWNoZUtleSIsIlRlbXBsYXRlQ29udGV4dCIsImtleSIsIkVycm9yQm91bmRhcnkiLCJlcnJvckNvbXBvbmVudCIsIk5vdEZvdW5kQm91bmRhcnkiLCJSZWRpcmVjdEJvdW5kYXJ5IiwiaXNBY3RpdmUiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/layout-router.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/render-from-template-context.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/render-from-template-context.js ***!
  \**********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return RenderFromTemplateContext;\n    }\n}));\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-client)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _approutercontext = __webpack_require__(/*! ../../shared/lib/app-router-context */ \"(app-client)/./node_modules/next/dist/shared/lib/app-router-context.js\");\nfunction RenderFromTemplateContext() {\n    const children = (0, _react.useContext)(_approutercontext.TemplateContext);\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, children);\n}\n_c = RenderFromTemplateContext;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=render-from-template-context.js.map\nvar _c;\n$RefreshReg$(_c, \"RenderFromTemplateContext\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZW5kZXItZnJvbS10ZW1wbGF0ZS1jb250ZXh0LmpzLmpzIiwibWFwcGluZ3MiOiJxREFDYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGSCwyQ0FBMEM7SUFDdENJLFlBQVksSUFBSTtJQUNoQkMsS0FBSyxXQUFXO1FBQ1osT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLDRCQUE0QkMsbUJBQU9BLENBQUMsMkhBQTBDO0FBQ3BGLE1BQU1DLFNBQVMsV0FBVyxHQUFHRiwwQkFBMEJHLENBQUMsQ0FBQ0YsbUJBQU9BLENBQUMsNEVBQU87QUFDeEUsTUFBTUcsb0JBQW9CSCxtQkFBT0EsQ0FBQyxtSEFBcUM7QUFFdkUsU0FBU0YsNEJBQTRCO0lBQ2pDLE1BQU1NLFdBQVcsQ0FBQyxHQUFHSCxPQUFPSSxVQUFVLEVBQUVGLGtCQUFrQkcsZUFBZTtJQUN6RSxPQUFPLFdBQVcsR0FBR0wsT0FBT00sT0FBTyxDQUFDQyxhQUFhLENBQUNQLE9BQU9NLE9BQU8sQ0FBQ0UsUUFBUSxFQUFFLElBQUksRUFBRUw7QUFDckY7S0FIU047QUFLVCxJQUFJLENBQUMsT0FBT0osUUFBUWEsT0FBTyxLQUFLLGNBQWUsT0FBT2IsUUFBUWEsT0FBTyxLQUFLLFlBQVliLFFBQVFhLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2IsUUFBUWEsT0FBTyxDQUFDRyxVQUFVLEtBQUssYUFBYTtJQUNyS2xCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUWEsT0FBTyxFQUFFLGNBQWM7UUFBRVosT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9tQixNQUFNLENBQUNqQixRQUFRYSxPQUFPLEVBQUViO0lBQy9Ca0IsT0FBT2xCLE9BQU8sR0FBR0EsUUFBUWEsT0FBTztBQUNsQyxDQUFDLENBRUQsd0RBQXdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qcz84ZWU2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSZW5kZXJGcm9tVGVtcGxhdGVDb250ZXh0O1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkXCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcInJlYWN0XCIpKTtcbmNvbnN0IF9hcHByb3V0ZXJjb250ZXh0ID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0XCIpO1xuXG5mdW5jdGlvbiBSZW5kZXJGcm9tVGVtcGxhdGVDb250ZXh0KCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gKDAsIF9yZWFjdC51c2VDb250ZXh0KShfYXBwcm91dGVyY29udGV4dC5UZW1wbGF0ZUNvbnRleHQpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiUmVuZGVyRnJvbVRlbXBsYXRlQ29udGV4dCIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJyZXF1aXJlIiwiX3JlYWN0IiwiXyIsIl9hcHByb3V0ZXJjb250ZXh0IiwiY2hpbGRyZW4iLCJ1c2VDb250ZXh0IiwiVGVtcGxhdGVDb250ZXh0IiwiZGVmYXVsdCIsImNyZWF0ZUVsZW1lbnQiLCJGcmFnbWVudCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/render-from-template-context.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/searchparams-bailout-proxy.js":
/*!********************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/searchparams-bailout-proxy.js ***!
  \********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"createSearchParamsBailoutProxy\", ({\n    enumerable: true,\n    get: function() {\n        return createSearchParamsBailoutProxy;\n    }\n}));\nconst _staticgenerationbailout = __webpack_require__(/*! ./static-generation-bailout */ \"(app-client)/./node_modules/next/dist/client/components/static-generation-bailout.js\");\nfunction createSearchParamsBailoutProxy() {\n    return new Proxy({}, {\n        get (_target, prop) {\n            // React adds some properties on the object when serializing for client components\n            if (typeof prop === \"string\") {\n                (0, _staticgenerationbailout.staticGenerationBailout)(\"searchParams.\" + prop);\n            }\n        }\n    });\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=searchparams-bailout-proxy.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9zZWFyY2hwYXJhbXMtYmFpbG91dC1wcm94eS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGSCxrRUFBaUU7SUFDN0RJLFlBQVksSUFBSTtJQUNoQkMsS0FBSyxXQUFXO1FBQ1osT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLDJCQUEyQkMsbUJBQU9BLENBQUMseUhBQTZCO0FBQ3RFLFNBQVNGLGlDQUFpQztJQUN0QyxPQUFPLElBQUlHLE1BQU0sQ0FBQyxHQUFHO1FBQ2pCSixLQUFLSyxPQUFPLEVBQUVDLElBQUksRUFBRTtZQUNoQixrRkFBa0Y7WUFDbEYsSUFBSSxPQUFPQSxTQUFTLFVBQVU7Z0JBQ3pCLElBQUdKLHlCQUF5QkssdUJBQXVCLEVBQUUsa0JBQWtCRDtZQUM1RSxDQUFDO1FBQ0w7SUFDSjtBQUNKO0FBRUEsSUFBSSxDQUFDLE9BQU9ULFFBQVFXLE9BQU8sS0FBSyxjQUFlLE9BQU9YLFFBQVFXLE9BQU8sS0FBSyxZQUFZWCxRQUFRVyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9YLFFBQVFXLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktkLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUVcsT0FBTyxFQUFFLGNBQWM7UUFBRVYsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9lLE1BQU0sQ0FBQ2IsUUFBUVcsT0FBTyxFQUFFWDtJQUMvQmMsT0FBT2QsT0FBTyxHQUFHQSxRQUFRVyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxzREFBc0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9zZWFyY2hwYXJhbXMtYmFpbG91dC1wcm94eS5qcz9iNmRlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlU2VhcmNoUGFyYW1zQmFpbG91dFByb3h5XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVTZWFyY2hQYXJhbXNCYWlsb3V0UHJveHk7XG4gICAgfVxufSk7XG5jb25zdCBfc3RhdGljZ2VuZXJhdGlvbmJhaWxvdXQgPSByZXF1aXJlKFwiLi9zdGF0aWMtZ2VuZXJhdGlvbi1iYWlsb3V0XCIpO1xuZnVuY3Rpb24gY3JlYXRlU2VhcmNoUGFyYW1zQmFpbG91dFByb3h5KCkge1xuICAgIHJldHVybiBuZXcgUHJveHkoe30sIHtcbiAgICAgICAgZ2V0IChfdGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgICAgICAvLyBSZWFjdCBhZGRzIHNvbWUgcHJvcGVydGllcyBvbiB0aGUgb2JqZWN0IHdoZW4gc2VyaWFsaXppbmcgZm9yIGNsaWVudCBjb21wb25lbnRzXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAoMCwgX3N0YXRpY2dlbmVyYXRpb25iYWlsb3V0LnN0YXRpY0dlbmVyYXRpb25CYWlsb3V0KShcInNlYXJjaFBhcmFtcy5cIiArIHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlYXJjaHBhcmFtcy1iYWlsb3V0LXByb3h5LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJjcmVhdGVTZWFyY2hQYXJhbXNCYWlsb3V0UHJveHkiLCJfc3RhdGljZ2VuZXJhdGlvbmJhaWxvdXQiLCJyZXF1aXJlIiwiUHJveHkiLCJfdGFyZ2V0IiwicHJvcCIsInN0YXRpY0dlbmVyYXRpb25CYWlsb3V0IiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/searchparams-bailout-proxy.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/static-generation-bailout.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/static-generation-bailout.js ***!
  \*******************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"staticGenerationBailout\", ({\n    enumerable: true,\n    get: function() {\n        return staticGenerationBailout;\n    }\n}));\nconst _hooksservercontext = __webpack_require__(/*! ./hooks-server-context */ \"(app-client)/./node_modules/next/dist/client/components/hooks-server-context.js\");\nconst _staticgenerationasyncstorage = __webpack_require__(/*! ./static-generation-async-storage */ \"(app-client)/./node_modules/next/dist/client/components/static-generation-async-storage.js\");\nclass StaticGenBailoutError extends Error {\n    constructor(...args){\n        super(...args);\n        this.code = \"NEXT_STATIC_GEN_BAILOUT\";\n    }\n}\nconst staticGenerationBailout = (reason, opts)=>{\n    const staticGenerationStore = _staticgenerationasyncstorage.staticGenerationAsyncStorage.getStore();\n    if (staticGenerationStore == null ? void 0 : staticGenerationStore.forceStatic) {\n        return true;\n    }\n    if (staticGenerationStore == null ? void 0 : staticGenerationStore.dynamicShouldError) {\n        const { dynamic =\"error\" , link  } = opts || {};\n        const suffix = link ? \" See more info here: \" + link : \"\";\n        throw new StaticGenBailoutError('Page with `dynamic = \"' + dynamic + \"\\\"` couldn't be rendered statically because it used `\" + reason + \"`.\" + suffix);\n    }\n    if (staticGenerationStore) {\n        staticGenerationStore.revalidate = 0;\n    }\n    if (staticGenerationStore == null ? void 0 : staticGenerationStore.isStaticGeneration) {\n        const err = new _hooksservercontext.DynamicServerError(reason);\n        staticGenerationStore.dynamicUsageDescription = reason;\n        staticGenerationStore.dynamicUsageStack = err.stack;\n        throw err;\n    }\n    return false;\n};\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=static-generation-bailout.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9zdGF0aWMtZ2VuZXJhdGlvbi1iYWlsb3V0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZILDJEQUEwRDtJQUN0REksWUFBWSxJQUFJO0lBQ2hCQyxLQUFLLFdBQVc7UUFDWixPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsc0JBQXNCQyxtQkFBT0EsQ0FBQywrR0FBd0I7QUFDNUQsTUFBTUMsZ0NBQWdDRCxtQkFBT0EsQ0FBQyxxSUFBbUM7QUFDakYsTUFBTUUsOEJBQThCQztJQUNoQ0MsWUFBWSxHQUFHQyxJQUFJLENBQUM7UUFDaEIsS0FBSyxJQUFJQTtRQUNULElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2hCO0FBQ0o7QUFDQSxNQUFNUiwwQkFBMEIsQ0FBQ1MsUUFBUUMsT0FBTztJQUM1QyxNQUFNQyx3QkFBd0JSLDhCQUE4QlMsNEJBQTRCLENBQUNDLFFBQVE7SUFDakcsSUFBSUYseUJBQXlCLElBQUksR0FBRyxLQUFLLElBQUlBLHNCQUFzQkcsV0FBVyxFQUFFO1FBQzVFLE9BQU8sSUFBSTtJQUNmLENBQUM7SUFDRCxJQUFJSCx5QkFBeUIsSUFBSSxHQUFHLEtBQUssSUFBSUEsc0JBQXNCSSxrQkFBa0IsRUFBRTtRQUNuRixNQUFNLEVBQUVDLFNBQVMsUUFBTyxFQUFHQyxLQUFJLEVBQUcsR0FBR1AsUUFBUSxDQUFDO1FBQzlDLE1BQU1RLFNBQVNELE9BQU8sMEJBQTBCQSxPQUFPLEVBQUU7UUFDekQsTUFBTSxJQUFJYixzQkFBc0IsMkJBQTJCWSxVQUFVLDBEQUEwRFAsU0FBUyxPQUFPUyxRQUFRO0lBQzNKLENBQUM7SUFDRCxJQUFJUCx1QkFBdUI7UUFDdkJBLHNCQUFzQlEsVUFBVSxHQUFHO0lBQ3ZDLENBQUM7SUFDRCxJQUFJUix5QkFBeUIsSUFBSSxHQUFHLEtBQUssSUFBSUEsc0JBQXNCUyxrQkFBa0IsRUFBRTtRQUNuRixNQUFNQyxNQUFNLElBQUlwQixvQkFBb0JxQixrQkFBa0IsQ0FBQ2I7UUFDdkRFLHNCQUFzQlksdUJBQXVCLEdBQUdkO1FBQ2hERSxzQkFBc0JhLGlCQUFpQixHQUFHSCxJQUFJSSxLQUFLO1FBQ25ELE1BQU1KLElBQUk7SUFDZCxDQUFDO0lBQ0QsT0FBTyxLQUFLO0FBQ2hCO0FBRUEsSUFBSSxDQUFDLE9BQU96QixRQUFROEIsT0FBTyxLQUFLLGNBQWUsT0FBTzlCLFFBQVE4QixPQUFPLEtBQUssWUFBWTlCLFFBQVE4QixPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU85QixRQUFROEIsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS2pDLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUThCLE9BQU8sRUFBRSxjQUFjO1FBQUU3QixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT2tDLE1BQU0sQ0FBQ2hDLFFBQVE4QixPQUFPLEVBQUU5QjtJQUMvQmlDLE9BQU9qQyxPQUFPLEdBQUdBLFFBQVE4QixPQUFPO0FBQ2xDLENBQUMsQ0FFRCxxREFBcUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9zdGF0aWMtZ2VuZXJhdGlvbi1iYWlsb3V0LmpzPzA0NmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdGF0aWNHZW5lcmF0aW9uQmFpbG91dFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3RhdGljR2VuZXJhdGlvbkJhaWxvdXQ7XG4gICAgfVxufSk7XG5jb25zdCBfaG9va3NzZXJ2ZXJjb250ZXh0ID0gcmVxdWlyZShcIi4vaG9va3Mtc2VydmVyLWNvbnRleHRcIik7XG5jb25zdCBfc3RhdGljZ2VuZXJhdGlvbmFzeW5jc3RvcmFnZSA9IHJlcXVpcmUoXCIuL3N0YXRpYy1nZW5lcmF0aW9uLWFzeW5jLXN0b3JhZ2VcIik7XG5jbGFzcyBTdGF0aWNHZW5CYWlsb3V0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLmNvZGUgPSBcIk5FWFRfU1RBVElDX0dFTl9CQUlMT1VUXCI7XG4gICAgfVxufVxuY29uc3Qgc3RhdGljR2VuZXJhdGlvbkJhaWxvdXQgPSAocmVhc29uLCBvcHRzKT0+e1xuICAgIGNvbnN0IHN0YXRpY0dlbmVyYXRpb25TdG9yZSA9IF9zdGF0aWNnZW5lcmF0aW9uYXN5bmNzdG9yYWdlLnN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKTtcbiAgICBpZiAoc3RhdGljR2VuZXJhdGlvblN0b3JlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0aWNHZW5lcmF0aW9uU3RvcmUuZm9yY2VTdGF0aWMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChzdGF0aWNHZW5lcmF0aW9uU3RvcmUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRpY0dlbmVyYXRpb25TdG9yZS5keW5hbWljU2hvdWxkRXJyb3IpIHtcbiAgICAgICAgY29uc3QgeyBkeW5hbWljID1cImVycm9yXCIgLCBsaW5rICB9ID0gb3B0cyB8fCB7fTtcbiAgICAgICAgY29uc3Qgc3VmZml4ID0gbGluayA/IFwiIFNlZSBtb3JlIGluZm8gaGVyZTogXCIgKyBsaW5rIDogXCJcIjtcbiAgICAgICAgdGhyb3cgbmV3IFN0YXRpY0dlbkJhaWxvdXRFcnJvcignUGFnZSB3aXRoIGBkeW5hbWljID0gXCInICsgZHluYW1pYyArIFwiXFxcImAgY291bGRuJ3QgYmUgcmVuZGVyZWQgc3RhdGljYWxseSBiZWNhdXNlIGl0IHVzZWQgYFwiICsgcmVhc29uICsgXCJgLlwiICsgc3VmZml4KTtcbiAgICB9XG4gICAgaWYgKHN0YXRpY0dlbmVyYXRpb25TdG9yZSkge1xuICAgICAgICBzdGF0aWNHZW5lcmF0aW9uU3RvcmUucmV2YWxpZGF0ZSA9IDA7XG4gICAgfVxuICAgIGlmIChzdGF0aWNHZW5lcmF0aW9uU3RvcmUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRpY0dlbmVyYXRpb25TdG9yZS5pc1N0YXRpY0dlbmVyYXRpb24pIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IF9ob29rc3NlcnZlcmNvbnRleHQuRHluYW1pY1NlcnZlckVycm9yKHJlYXNvbik7XG4gICAgICAgIHN0YXRpY0dlbmVyYXRpb25TdG9yZS5keW5hbWljVXNhZ2VEZXNjcmlwdGlvbiA9IHJlYXNvbjtcbiAgICAgICAgc3RhdGljR2VuZXJhdGlvblN0b3JlLmR5bmFtaWNVc2FnZVN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRpYy1nZW5lcmF0aW9uLWJhaWxvdXQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsInN0YXRpY0dlbmVyYXRpb25CYWlsb3V0IiwiX2hvb2tzc2VydmVyY29udGV4dCIsInJlcXVpcmUiLCJfc3RhdGljZ2VuZXJhdGlvbmFzeW5jc3RvcmFnZSIsIlN0YXRpY0dlbkJhaWxvdXRFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJhcmdzIiwiY29kZSIsInJlYXNvbiIsIm9wdHMiLCJzdGF0aWNHZW5lcmF0aW9uU3RvcmUiLCJzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlIiwiZ2V0U3RvcmUiLCJmb3JjZVN0YXRpYyIsImR5bmFtaWNTaG91bGRFcnJvciIsImR5bmFtaWMiLCJsaW5rIiwic3VmZml4IiwicmV2YWxpZGF0ZSIsImlzU3RhdGljR2VuZXJhdGlvbiIsImVyciIsIkR5bmFtaWNTZXJ2ZXJFcnJvciIsImR5bmFtaWNVc2FnZURlc2NyaXB0aW9uIiwiZHluYW1pY1VzYWdlU3RhY2siLCJzdGFjayIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/static-generation-bailout.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/static-generation-searchparams-bailout-provider.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/static-generation-searchparams-bailout-provider.js ***!
  \*****************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return StaticGenerationSearchParamsBailoutProvider;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-client)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _searchparamsbailoutproxy = __webpack_require__(/*! ./searchparams-bailout-proxy */ \"(app-client)/./node_modules/next/dist/client/components/searchparams-bailout-proxy.js\");\nfunction StaticGenerationSearchParamsBailoutProvider(param) {\n    let { Component , propsForComponent  } = param;\n    const searchParams = (0, _searchparamsbailoutproxy.createSearchParamsBailoutProxy)();\n    return /*#__PURE__*/ _react.default.createElement(Component, {\n        searchParams: searchParams,\n        ...propsForComponent\n    });\n}\n_c = StaticGenerationSearchParamsBailoutProvider;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=static-generation-searchparams-bailout-provider.js.map\nvar _c;\n$RefreshReg$(_c, \"StaticGenerationSearchParamsBailoutProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9zdGF0aWMtZ2VuZXJhdGlvbi1zZWFyY2hwYXJhbXMtYmFpbG91dC1wcm92aWRlci5qcy5qcyIsIm1hcHBpbmdzIjoicURBQ2E7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkgsMkNBQTBDO0lBQ3RDSSxZQUFZLElBQUk7SUFDaEJDLEtBQUssV0FBVztRQUNaLE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQywyQkFBMkJDLG1CQUFPQSxDQUFDLHlIQUF5QztBQUNsRixNQUFNQyxTQUFTLFdBQVcsR0FBR0YseUJBQXlCRyxDQUFDLENBQUNGLG1CQUFPQSxDQUFDLDRFQUFPO0FBQ3ZFLE1BQU1HLDRCQUE0QkgsbUJBQU9BLENBQUMsMkhBQThCO0FBRXhFLFNBQVNGLDRDQUE0Q00sS0FBSyxFQUFFO0lBQ3hELElBQUksRUFBRUMsVUFBUyxFQUFHQyxrQkFBaUIsRUFBRyxHQUFHRjtJQUN6QyxNQUFNRyxlQUFlLENBQUMsR0FBR0osMEJBQTBCSyw4QkFBOEI7SUFDakYsT0FBTyxXQUFXLEdBQUdQLE9BQU9RLE9BQU8sQ0FBQ0MsYUFBYSxDQUFDTCxXQUFXO1FBQ3pERSxjQUFjQTtRQUNkLEdBQUdELGlCQUFpQjtJQUN4QjtBQUNKO0tBUFNSO0FBU1QsSUFBSSxDQUFDLE9BQU9KLFFBQVFlLE9BQU8sS0FBSyxjQUFlLE9BQU9mLFFBQVFlLE9BQU8sS0FBSyxZQUFZZixRQUFRZSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9mLFFBQVFlLE9BQU8sQ0FBQ0UsVUFBVSxLQUFLLGFBQWE7SUFDcktuQixPQUFPQyxjQUFjLENBQUNDLFFBQVFlLE9BQU8sRUFBRSxjQUFjO1FBQUVkLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPb0IsTUFBTSxDQUFDbEIsUUFBUWUsT0FBTyxFQUFFZjtJQUMvQm1CLE9BQU9uQixPQUFPLEdBQUdBLFFBQVFlLE9BQU87QUFDbEMsQ0FBQyxDQUVELDJFQUEyRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3N0YXRpYy1nZW5lcmF0aW9uLXNlYXJjaHBhcmFtcy1iYWlsb3V0LXByb3ZpZGVyLmpzPzk3MWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFN0YXRpY0dlbmVyYXRpb25TZWFyY2hQYXJhbXNCYWlsb3V0UHJvdmlkZXI7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgX3NlYXJjaHBhcmFtc2JhaWxvdXRwcm94eSA9IHJlcXVpcmUoXCIuL3NlYXJjaHBhcmFtcy1iYWlsb3V0LXByb3h5XCIpO1xuXG5mdW5jdGlvbiBTdGF0aWNHZW5lcmF0aW9uU2VhcmNoUGFyYW1zQmFpbG91dFByb3ZpZGVyKHBhcmFtKSB7XG4gICAgbGV0IHsgQ29tcG9uZW50ICwgcHJvcHNGb3JDb21wb25lbnQgIH0gPSBwYXJhbTtcbiAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSAoMCwgX3NlYXJjaHBhcmFtc2JhaWxvdXRwcm94eS5jcmVhdGVTZWFyY2hQYXJhbXNCYWlsb3V0UHJveHkpKCk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIHtcbiAgICAgICAgc2VhcmNoUGFyYW1zOiBzZWFyY2hQYXJhbXMsXG4gICAgICAgIC4uLnByb3BzRm9yQ29tcG9uZW50XG4gICAgfSk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRpYy1nZW5lcmF0aW9uLXNlYXJjaHBhcmFtcy1iYWlsb3V0LXByb3ZpZGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJTdGF0aWNHZW5lcmF0aW9uU2VhcmNoUGFyYW1zQmFpbG91dFByb3ZpZGVyIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9yZWFjdCIsIl8iLCJfc2VhcmNocGFyYW1zYmFpbG91dHByb3h5IiwicGFyYW0iLCJDb21wb25lbnQiLCJwcm9wc0ZvckNvbXBvbmVudCIsInNlYXJjaFBhcmFtcyIsImNyZWF0ZVNlYXJjaFBhcmFtc0JhaWxvdXRQcm94eSIsImRlZmF1bHQiLCJjcmVhdGVFbGVtZW50IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/static-generation-searchparams-bailout-provider.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js":
/*!********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js ***!
  \********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Run function with `scroll-behavior: auto` applied to `<html/>`.\n * This css change will be reverted after the function finishes.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"handleSmoothScroll\", ({\n    enumerable: true,\n    get: function() {\n        return handleSmoothScroll;\n    }\n}));\nfunction handleSmoothScroll(fn, options) {\n    if (options === void 0) options = {};\n    const htmlElement = document.documentElement;\n    const existing = htmlElement.style.scrollBehavior;\n    htmlElement.style.scrollBehavior = \"auto\";\n    if (!options.dontForceLayout) {\n        // In Chrome-based browsers we need to force reflow before calling `scrollTo`.\n        // Otherwise it will not pickup the change in scrollBehavior\n        // More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042\n        htmlElement.getClientRects();\n    }\n    fn();\n    htmlElement.style.scrollBehavior = existing;\n} //# sourceMappingURL=handle-smooth-scroll.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9oYW5kbGUtc21vb3RoLXNjcm9sbC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7O0NBR0MsR0FBZ0I7QUFDakJBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZILHNEQUFxRDtJQUNqREksWUFBWSxJQUFJO0lBQ2hCQyxLQUFLLFdBQVc7UUFDWixPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsU0FBU0EsbUJBQW1CQyxFQUFFLEVBQUVDLE9BQU8sRUFBRTtJQUNyQyxJQUFJQSxZQUFZLEtBQUssR0FBR0EsVUFBVSxDQUFDO0lBQ25DLE1BQU1DLGNBQWNDLFNBQVNDLGVBQWU7SUFDNUMsTUFBTUMsV0FBV0gsWUFBWUksS0FBSyxDQUFDQyxjQUFjO0lBQ2pETCxZQUFZSSxLQUFLLENBQUNDLGNBQWMsR0FBRztJQUNuQyxJQUFJLENBQUNOLFFBQVFPLGVBQWUsRUFBRTtRQUMxQiw4RUFBOEU7UUFDOUUsNERBQTREO1FBQzVELHlGQUF5RjtRQUN6Rk4sWUFBWU8sY0FBYztJQUM5QixDQUFDO0lBQ0RUO0lBQ0FFLFlBQVlJLEtBQUssQ0FBQ0MsY0FBYyxHQUFHRjtBQUN2QyxFQUVBLGdEQUFnRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2hhbmRsZS1zbW9vdGgtc2Nyb2xsLmpzPzY1NjMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSdW4gZnVuY3Rpb24gd2l0aCBgc2Nyb2xsLWJlaGF2aW9yOiBhdXRvYCBhcHBsaWVkIHRvIGA8aHRtbC8+YC5cbiAqIFRoaXMgY3NzIGNoYW5nZSB3aWxsIGJlIHJldmVydGVkIGFmdGVyIHRoZSBmdW5jdGlvbiBmaW5pc2hlcy5cbiAqLyBcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhhbmRsZVNtb290aFNjcm9sbFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlU21vb3RoU2Nyb2xsO1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gaGFuZGxlU21vb3RoU2Nyb2xsKGZuLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgIGNvbnN0IGh0bWxFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIGNvbnN0IGV4aXN0aW5nID0gaHRtbEVsZW1lbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3I7XG4gICAgaHRtbEVsZW1lbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSBcImF1dG9cIjtcbiAgICBpZiAoIW9wdGlvbnMuZG9udEZvcmNlTGF5b3V0KSB7XG4gICAgICAgIC8vIEluIENocm9tZS1iYXNlZCBicm93c2VycyB3ZSBuZWVkIHRvIGZvcmNlIHJlZmxvdyBiZWZvcmUgY2FsbGluZyBgc2Nyb2xsVG9gLlxuICAgICAgICAvLyBPdGhlcndpc2UgaXQgd2lsbCBub3QgcGlja3VwIHRoZSBjaGFuZ2UgaW4gc2Nyb2xsQmVoYXZpb3JcbiAgICAgICAgLy8gTW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9pc3N1ZXMvNDA3MTkjaXNzdWVjb21tZW50LTEzMzYyNDgwNDJcbiAgICAgICAgaHRtbEVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICB9XG4gICAgZm4oKTtcbiAgICBodG1sRWxlbWVudC5zdHlsZS5zY3JvbGxCZWhhdmlvciA9IGV4aXN0aW5nO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYW5kbGUtc21vb3RoLXNjcm9sbC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiaGFuZGxlU21vb3RoU2Nyb2xsIiwiZm4iLCJvcHRpb25zIiwiaHRtbEVsZW1lbnQiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImV4aXN0aW5nIiwic3R5bGUiLCJzY3JvbGxCZWhhdmlvciIsImRvbnRGb3JjZUxheW91dCIsImdldENsaWVudFJlY3RzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/static-generation-async-storage.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/static-generation-async-storage.js ***!
  \*************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"staticGenerationAsyncStorage\", ({\n    enumerable: true,\n    get: function() {\n        return staticGenerationAsyncStorage;\n    }\n}));\nconst _asynclocalstorage = __webpack_require__(/*! ./async-local-storage */ \"(app-client)/./node_modules/next/dist/client/components/async-local-storage.js\");\nconst staticGenerationAsyncStorage = (0, _asynclocalstorage.createAsyncLocalStorage)();\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=static-generation-async-storage.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9zdGF0aWMtZ2VuZXJhdGlvbi1hc3luYy1zdG9yYWdlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZILGdFQUErRDtJQUMzREksWUFBWSxJQUFJO0lBQ2hCQyxLQUFLLFdBQVc7UUFDWixPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMscUJBQXFCQyxtQkFBT0EsQ0FBQyw2R0FBdUI7QUFDMUQsTUFBTUYsK0JBQStCLENBQUMsR0FBR0MsbUJBQW1CRSx1QkFBdUI7QUFFbkYsSUFBSSxDQUFDLE9BQU9QLFFBQVFRLE9BQU8sS0FBSyxjQUFlLE9BQU9SLFFBQVFRLE9BQU8sS0FBSyxZQUFZUixRQUFRUSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9SLFFBQVFRLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktYLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUVEsT0FBTyxFQUFFLGNBQWM7UUFBRVAsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9ZLE1BQU0sQ0FBQ1YsUUFBUVEsT0FBTyxFQUFFUjtJQUMvQlcsT0FBT1gsT0FBTyxHQUFHQSxRQUFRUSxPQUFPO0FBQ2xDLENBQUMsQ0FFRCwyREFBMkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9zdGF0aWMtZ2VuZXJhdGlvbi1hc3luYy1zdG9yYWdlLmpzPzJiMjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlO1xuICAgIH1cbn0pO1xuY29uc3QgX2FzeW5jbG9jYWxzdG9yYWdlID0gcmVxdWlyZShcIi4vYXN5bmMtbG9jYWwtc3RvcmFnZVwiKTtcbmNvbnN0IHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UgPSAoMCwgX2FzeW5jbG9jYWxzdG9yYWdlLmNyZWF0ZUFzeW5jTG9jYWxTdG9yYWdlKSgpO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGF0aWMtZ2VuZXJhdGlvbi1hc3luYy1zdG9yYWdlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlIiwiX2FzeW5jbG9jYWxzdG9yYWdlIiwicmVxdWlyZSIsImNyZWF0ZUFzeW5jTG9jYWxTdG9yYWdlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/static-generation-async-storage.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-client)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fsalamane%2FDesktop%2Fft_transcendence%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fapp-router.js&modules=%2FUsers%2Fsalamane%2FDesktop%2Fft_transcendence%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js&modules=%2FUsers%2Fsalamane%2FDesktop%2Fft_transcendence%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js&modules=%2FUsers%2Fsalamane%2FDesktop%2Fft_transcendence%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Ferror-boundary.js&modules=%2FUsers%2Fsalamane%2FDesktop%2Fft_transcendence%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fstatic-generation-searchparams-bailout-provider.js&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);